/*! algoliasearch 3.1.0 | Â© 2014, 2015 Algolia SAS | github.com/algolia/algoliasearch-client-js */
(function(f){var g;if(typeof window!=='undefined'){g=window}else if(typeof self!=='undefined'){g=self}g.ALGOLIA_MIGRATION_LAYER=f()})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

    module.exports = function load (src, opts, cb) {
        var head = document.head || document.getElementsByTagName('head')[0]
        var script = document.createElement('script')

        if (typeof opts === 'function') {
            cb = opts
            opts = {}
        }

        opts = opts || {}
        cb = cb || function() {}

        script.type = opts.type || 'text/javascript'
        script.charset = opts.charset || 'utf8';
        script.async = 'async' in opts ? !!opts.async : true
        script.src = src

        if (opts.attrs) {
            setAttributes(script, opts.attrs)
        }

        if (opts.text) {
            script.text = '' + opts.text
        }

        var onend = 'onload' in script ? stdOnEnd : ieOnEnd
        onend(script, cb)

        // some good legacy browsers (firefox) fail the 'in' detection above
        // so as a fallback we always set onload
        // old IE will ignore this and new IE will set onload
        if (!script.onload) {
            stdOnEnd(script, cb);
        }

        head.appendChild(script)
    }

    function setAttributes(script, attrs) {
        for (var attr in attrs) {
            script.setAttribute(attr, attrs[attr]);
        }
    }

    function stdOnEnd (script, cb) {
        script.onload = function () {
            this.onerror = this.onload = null
            cb(null, script)
        }
        script.onerror = function () {
            // this.onload = null here is necessary
            // because even IE9 works not like others
            this.onerror = this.onload = null
            cb(new Error('Failed to load ' + this.src), script)
        }
    }

    function ieOnEnd (script, cb) {
        script.onreadystatechange = function () {
            if (this.readyState != 'complete' && this.readyState != 'loaded') return
            this.onreadystatechange = null
            cb(null, script) // there is no way to catch loading errors in IE8
        }
    }

},{}],2:[function(require,module,exports){
// this module helps finding if the current page is using
// the cdn.jsdelivr.net/algoliasearch/latest/$BUILDNAME.min.js version

    module.exports = isUsingLatest;

    function isUsingLatest(buildName) {
        var toFind = new RegExp('cdn\\.jsdelivr\\.net/algoliasearch/latest/' +
        buildName.replace('.', '\\.') + // algoliasearch, algoliasearch.angular
        '(?:\\.min)?\\.js$'); // [.min].js

        var scripts = document.getElementsByTagName('script');
        var found = false;
        for (var currentScript = 0, nbScripts = scripts.length;
             currentScript < nbScripts;
             currentScript++) {
            if (scripts[currentScript].src && toFind.test(scripts[currentScript].src)) {
                found = true;
                break;
            }
        }

        return found;
    }

},{}],3:[function(require,module,exports){
    (function (global){
        module.exports = loadV2;

        function loadV2(buildName) {
            var loadScript = require(1);
            var v2ScriptUrl = '//cdn.jsdelivr.net/algoliasearch/2/' + buildName + '.min.js';

            var message =
                '-- AlgoliaSearch `latest` warning --\n' +
                'Warning, you are using the `latest` version string from jsDelivr to load the AlgoliaSearch library.\n' +
                'Using `latest` is no more recommended, you should load //cdn.jsdelivr.net/algoliasearch/2/algoliasearch.min.js\n\n' +
                'Also, we updated the AlgoliaSearch JavaScript client to V3. If you want to upgrade,\n' +
                'please read our migration guide at https://github.com/algolia/algoliasearch-client-js/wiki/Migration-guide-from-2.x.x-to-3.x.x\n' +
                '-- /AlgoliaSearch  `latest` warning --';

            if (global.console) {
                if (global.console.warn) {
                    global.console.warn(message);
                } else if (global.console.log) {
                    global.console.log(message);
                }
            }

            // If current script loaded asynchronously,
            // it will load the script with DOMElement
            // otherwise, it will load the script with document.write
            try {
                // why \x3c? http://stackoverflow.com/a/236106/147079
                document.write('\x3Cscript>window.ALGOLIA_SUPPORTS_DOCWRITE = true\x3C/script>');

                if (global.ALGOLIA_SUPPORTS_DOCWRITE === true) {
                    document.write('\x3Cscript src="' + v2ScriptUrl + '">\x3C/script>');
                    scriptLoaded('document.write')();
                } else {
                    loadScript(v2ScriptUrl, scriptLoaded('DOMElement'));
                }
            } catch(e) {
                loadScript(v2ScriptUrl, scriptLoaded('DOMElement'));
            }
        }

        function scriptLoaded(method) {
            return function log() {
                var message = 'AlgoliaSearch: loaded V2 script using ' + method;

                global.console && global.console.log && global.console.log(message);
            };
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"1":1}],4:[function(require,module,exports){
    (function (global){
        /*global AlgoliaExplainResults:true*/
        /*eslint no-unused-vars: [2, {"vars": "local"}]*/

        module.exports = oldGlobals;

// put old window.AlgoliaSearch.. into window. again so that
// users upgrading to V3 without changing their code, will be warned
        function oldGlobals() {
            var message =
                '-- AlgoliaSearch V2 => V3 error --\n' +
                'You are trying to use a new version of the AlgoliaSearch JavaScript client with an old notation.\n' +
                'Please read our migration guide at https://github.com/algolia/algoliasearch-client-js/wiki/Migration-guide-from-2.x.x-to-3.x.x\n' +
                '-- /AlgoliaSearch V2 => V3 error --';

            global.AlgoliaSearch = function() {
                throw new Error(message);
            };

            global.AlgoliaSearchHelper = function() {
                throw new Error(message);
            };

            // cannot use window.AlgoliaExplainResults on old IEs, dunno why
            AlgoliaExplainResults = function() {
                throw new Error(message);
            };
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
// This script will be browserified and prepended to the normal build
// directly in window, not wrapped in any module definition
// To avoid cases where we are loaded with /latest/ along with
    migrationLayer("algoliasearch");

// Now onto the V2 related code:
//  If the client is using /latest/$BUILDNAME.min.js, load V2 of the library
//
//  Otherwise, setup a migration layer that will throw on old constructors like
//  new AlgoliaSearch().
//  So that users upgrading from v2 to v3 will have a clear information
//  message on what to do if they did not read the migration guide
    function migrationLayer(buildName) {
        var isUsingLatest = require(2);
        var loadV2 = require(3);
        var oldGlobals = require(4);

        if (isUsingLatest(buildName)) {
            loadV2(buildName);
        } else {
            oldGlobals();
        }
    }

},{"2":2,"3":3,"4":4}]},{},[5])(5)
});(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.algoliasearch = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;

    function drainQueue() {
        if (draining) {
            return;
        }
        draining = true;
        var currentQueue;
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            var i = -1;
            while (++i < len) {
                currentQueue[i]();
            }
            len = queue.length;
        }
        draining = false;
    }
    process.nextTick = function (fun) {
        queue.push(fun);
        if (!draining) {
            setTimeout(drainQueue, 0);
        }
    };

    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

// TODO(shtylman)
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    module.exports = function(qs, sep, eq, options) {
        sep = sep || '&';
        eq = eq || '=';
        var obj = {};

        if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
        }

        var regexp = /\+/g;
        qs = qs.split(sep);

        var maxKeys = 1000;
        if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
        }

        var len = qs.length;
        // maxKeys <= 0 means that we should not limit keys count
        if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
        }

        for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr, vstr, k, v;

            if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
            } else {
                kstr = x;
                vstr = '';
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!hasOwnProperty(obj, k)) {
                obj[k] = v;
            } else if (isArray(obj[k])) {
                obj[k].push(v);
            } else {
                obj[k] = [obj[k], v];
            }
        }

        return obj;
    };

    var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };

},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var stringifyPrimitive = function(v) {
        switch (typeof v) {
            case 'string':
                return v;

            case 'boolean':
                return v ? 'true' : 'false';

            case 'number':
                return isFinite(v) ? v : '';

            default:
                return '';
        }
    };

    module.exports = function(obj, sep, eq, name) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
            obj = undefined;
        }

        if (typeof obj === 'object') {
            return map(objectKeys(obj), function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (isArray(obj[k])) {
                    return map(obj[k], function(v) {
                        return ks + encodeURIComponent(stringifyPrimitive(v));
                    }).join(sep);
                } else {
                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
            }).join(sep);

        }

        if (!name) return '';
        return encodeURIComponent(stringifyPrimitive(name)) + eq +
            encodeURIComponent(stringifyPrimitive(obj));
    };

    var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };

    function map (xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
        }
        return res;
    }

    var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
        };

},{}],4:[function(require,module,exports){
    'use strict';

    exports.decode = exports.parse = require(2);
    exports.encode = exports.stringify = require(3);

},{"2":2,"3":3}],5:[function(require,module,exports){

    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = require(6);
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;

    /**
     * Use chrome.storage.local if we are in an app
     */

    var storage;

    if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
        storage = chrome.storage.local;
    else
        storage = localstorage();

    /**
     * Colors.
     */

    exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
        // is webkit? http://stackoverflow.com/a/16459606/376773
        return ('WebkitAppearance' in document.documentElement.style) ||
                // is firebug? http://stackoverflow.com/a/398120/376773
            (window.console && (console.firebug || (console.exception && console.table))) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
        return JSON.stringify(v);
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;

        args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);

        if (!useColors) return args;

        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
            if ('%%' === match) return;
            index++;
            if ('%c' === match) {
                // we only are interested in the *last* %c
                // (the user may have provided their own)
                lastC = index;
            }
        });

        args.splice(lastC, 0, c);
        return args;
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
        // this hackery is required for IE8/9, where
        // the `console.log` function doesn't have 'apply'
        return 'object' === typeof console
            && console.log
            && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
        try {
            if (null == namespaces) {
                storage.removeItem('debug');
            } else {
                storage.debug = namespaces;
            }
        } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
        var r;
        try {
            r = storage.debug;
        } catch(e) {}
        return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage(){
        try {
            return window.localStorage;
        } catch (e) {}
    }

},{"6":6}],6:[function(require,module,exports){

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require(7);

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */

    exports.formatters = {};

    /**
     * Previously assigned color.
     */

    var prevColor = 0;

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */

    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function debug(namespace) {

        // define the `disabled` version
        function disabled() {
        }
        disabled.enabled = false;

        // define the `enabled` version
        function enabled() {

            var self = enabled;

            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;

            // add the `color` if not set
            if (null == self.useColors) self.useColors = exports.useColors();
            if (null == self.color && self.useColors) self.color = selectColor();

            var args = Array.prototype.slice.call(arguments);

            args[0] = exports.coerce(args[0]);

            if ('string' !== typeof args[0]) {
                // anything else let's inspect with %o
                args = ['%o'].concat(args);
            }

            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === '%%') return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);

                    // now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });

            if ('function' === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args);
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
        }
        enabled.enabled = true;

        var fn = exports.enabled(namespace) ? enabled : disabled;

        fn.namespace = namespace;

        return fn;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
        exports.save(namespaces);

        var split = (namespaces || '').split(/[\s,]+/);
        var len = split.length;

        for (var i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
        exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false;
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }

},{"7":7}],7:[function(require,module,exports){
    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */

    module.exports = function(val, options){
        options = options || {};
        if ('string' == typeof val) return parse(val);
        return options.long
            ? long(val)
            : short(val);
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
        if (!match) return;
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
                return n * y;
            case 'days':
            case 'day':
            case 'd':
                return n * d;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
                return n * h;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
                return n * m;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
                return n * s;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
                return n;
        }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function short(ms) {
        if (ms >= d) return Math.round(ms / d) + 'd';
        if (ms >= h) return Math.round(ms / h) + 'h';
        if (ms >= m) return Math.round(ms / m) + 'm';
        if (ms >= s) return Math.round(ms / s) + 's';
        return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function long(ms) {
        return plural(ms, d, 'day')
            || plural(ms, h, 'hour')
            || plural(ms, m, 'minute')
            || plural(ms, s, 'second')
            || ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, n, name) {
        if (ms < n) return;
        if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
        return Math.ceil(ms / n) + ' ' + name + 's';
    }

},{}],8:[function(require,module,exports){
    (function (process,global){
        /*!
         * @overview es6-promise - a tiny implementation of Promises/A+.
         * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
         * @license   Licensed under MIT license
         *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
         * @version   2.0.1
         */

        (function() {
            "use strict";

            function $$utils$$objectOrFunction(x) {
                return typeof x === 'function' || (typeof x === 'object' && x !== null);
            }

            function $$utils$$isFunction(x) {
                return typeof x === 'function';
            }

            function $$utils$$isMaybeThenable(x) {
                return typeof x === 'object' && x !== null;
            }

            var $$utils$$_isArray;

            if (!Array.isArray) {
                $$utils$$_isArray = function (x) {
                    return Object.prototype.toString.call(x) === '[object Array]';
                };
            } else {
                $$utils$$_isArray = Array.isArray;
            }

            var $$utils$$isArray = $$utils$$_isArray;
            var $$utils$$now = Date.now || function() { return new Date().getTime(); };
            function $$utils$$F() { }

            var $$utils$$o_create = (Object.create || function (o) {
                if (arguments.length > 1) {
                    throw new Error('Second argument not supported');
                }
                if (typeof o !== 'object') {
                    throw new TypeError('Argument must be an object');
                }
                $$utils$$F.prototype = o;
                return new $$utils$$F();
            });

            var $$asap$$len = 0;

            var $$asap$$default = function asap(callback, arg) {
                $$asap$$queue[$$asap$$len] = callback;
                $$asap$$queue[$$asap$$len + 1] = arg;
                $$asap$$len += 2;
                if ($$asap$$len === 2) {
                    // If len is 1, that means that we need to schedule an async flush.
                    // If additional callbacks are queued before the queue is flushed, they
                    // will be processed by this flush that we are scheduling.
                    $$asap$$scheduleFlush();
                }
            };

            var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
            var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;

            // test for web worker but not in IE10
            var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
                typeof importScripts !== 'undefined' &&
                typeof MessageChannel !== 'undefined';

            // node
            function $$asap$$useNextTick() {
                return function() {
                    process.nextTick($$asap$$flush);
                };
            }

            function $$asap$$useMutationObserver() {
                var iterations = 0;
                var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
                var node = document.createTextNode('');
                observer.observe(node, { characterData: true });

                return function() {
                    node.data = (iterations = ++iterations % 2);
                };
            }

            // web worker
            function $$asap$$useMessageChannel() {
                var channel = new MessageChannel();
                channel.port1.onmessage = $$asap$$flush;
                return function () {
                    channel.port2.postMessage(0);
                };
            }

            function $$asap$$useSetTimeout() {
                return function() {
                    setTimeout($$asap$$flush, 1);
                };
            }

            var $$asap$$queue = new Array(1000);

            function $$asap$$flush() {
                for (var i = 0; i < $$asap$$len; i+=2) {
                    var callback = $$asap$$queue[i];
                    var arg = $$asap$$queue[i+1];

                    callback(arg);

                    $$asap$$queue[i] = undefined;
                    $$asap$$queue[i+1] = undefined;
                }

                $$asap$$len = 0;
            }

            var $$asap$$scheduleFlush;

            // Decide what async method to use to triggering processing of queued callbacks:
            if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
                $$asap$$scheduleFlush = $$asap$$useNextTick();
            } else if ($$asap$$BrowserMutationObserver) {
                $$asap$$scheduleFlush = $$asap$$useMutationObserver();
            } else if ($$asap$$isWorker) {
                $$asap$$scheduleFlush = $$asap$$useMessageChannel();
            } else {
                $$asap$$scheduleFlush = $$asap$$useSetTimeout();
            }

            function $$$internal$$noop() {}
            var $$$internal$$PENDING   = void 0;
            var $$$internal$$FULFILLED = 1;
            var $$$internal$$REJECTED  = 2;
            var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();

            function $$$internal$$selfFullfillment() {
                return new TypeError("You cannot resolve a promise with itself");
            }

            function $$$internal$$cannotReturnOwn() {
                return new TypeError('A promises callback cannot return that same promise.')
            }

            function $$$internal$$getThen(promise) {
                try {
                    return promise.then;
                } catch(error) {
                    $$$internal$$GET_THEN_ERROR.error = error;
                    return $$$internal$$GET_THEN_ERROR;
                }
            }

            function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
                try {
                    then.call(value, fulfillmentHandler, rejectionHandler);
                } catch(e) {
                    return e;
                }
            }

            function $$$internal$$handleForeignThenable(promise, thenable, then) {
                $$asap$$default(function(promise) {
                    var sealed = false;
                    var error = $$$internal$$tryThen(then, thenable, function(value) {
                        if (sealed) { return; }
                        sealed = true;
                        if (thenable !== value) {
                            $$$internal$$resolve(promise, value);
                        } else {
                            $$$internal$$fulfill(promise, value);
                        }
                    }, function(reason) {
                        if (sealed) { return; }
                        sealed = true;

                        $$$internal$$reject(promise, reason);
                    }, 'Settle: ' + (promise._label || ' unknown promise'));

                    if (!sealed && error) {
                        sealed = true;
                        $$$internal$$reject(promise, error);
                    }
                }, promise);
            }

            function $$$internal$$handleOwnThenable(promise, thenable) {
                if (thenable._state === $$$internal$$FULFILLED) {
                    $$$internal$$fulfill(promise, thenable._result);
                } else if (promise._state === $$$internal$$REJECTED) {
                    $$$internal$$reject(promise, thenable._result);
                } else {
                    $$$internal$$subscribe(thenable, undefined, function(value) {
                        $$$internal$$resolve(promise, value);
                    }, function(reason) {
                        $$$internal$$reject(promise, reason);
                    });
                }
            }

            function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
                if (maybeThenable.constructor === promise.constructor) {
                    $$$internal$$handleOwnThenable(promise, maybeThenable);
                } else {
                    var then = $$$internal$$getThen(maybeThenable);

                    if (then === $$$internal$$GET_THEN_ERROR) {
                        $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
                    } else if (then === undefined) {
                        $$$internal$$fulfill(promise, maybeThenable);
                    } else if ($$utils$$isFunction(then)) {
                        $$$internal$$handleForeignThenable(promise, maybeThenable, then);
                    } else {
                        $$$internal$$fulfill(promise, maybeThenable);
                    }
                }
            }

            function $$$internal$$resolve(promise, value) {
                if (promise === value) {
                    $$$internal$$reject(promise, $$$internal$$selfFullfillment());
                } else if ($$utils$$objectOrFunction(value)) {
                    $$$internal$$handleMaybeThenable(promise, value);
                } else {
                    $$$internal$$fulfill(promise, value);
                }
            }

            function $$$internal$$publishRejection(promise) {
                if (promise._onerror) {
                    promise._onerror(promise._result);
                }

                $$$internal$$publish(promise);
            }

            function $$$internal$$fulfill(promise, value) {
                if (promise._state !== $$$internal$$PENDING) { return; }

                promise._result = value;
                promise._state = $$$internal$$FULFILLED;

                if (promise._subscribers.length === 0) {
                } else {
                    $$asap$$default($$$internal$$publish, promise);
                }
            }

            function $$$internal$$reject(promise, reason) {
                if (promise._state !== $$$internal$$PENDING) { return; }
                promise._state = $$$internal$$REJECTED;
                promise._result = reason;

                $$asap$$default($$$internal$$publishRejection, promise);
            }

            function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
                var subscribers = parent._subscribers;
                var length = subscribers.length;

                parent._onerror = null;

                subscribers[length] = child;
                subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
                subscribers[length + $$$internal$$REJECTED]  = onRejection;

                if (length === 0 && parent._state) {
                    $$asap$$default($$$internal$$publish, parent);
                }
            }

            function $$$internal$$publish(promise) {
                var subscribers = promise._subscribers;
                var settled = promise._state;

                if (subscribers.length === 0) { return; }

                var child, callback, detail = promise._result;

                for (var i = 0; i < subscribers.length; i += 3) {
                    child = subscribers[i];
                    callback = subscribers[i + settled];

                    if (child) {
                        $$$internal$$invokeCallback(settled, child, callback, detail);
                    } else {
                        callback(detail);
                    }
                }

                promise._subscribers.length = 0;
            }

            function $$$internal$$ErrorObject() {
                this.error = null;
            }

            var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();

            function $$$internal$$tryCatch(callback, detail) {
                try {
                    return callback(detail);
                } catch(e) {
                    $$$internal$$TRY_CATCH_ERROR.error = e;
                    return $$$internal$$TRY_CATCH_ERROR;
                }
            }

            function $$$internal$$invokeCallback(settled, promise, callback, detail) {
                var hasCallback = $$utils$$isFunction(callback),
                    value, error, succeeded, failed;

                if (hasCallback) {
                    value = $$$internal$$tryCatch(callback, detail);

                    if (value === $$$internal$$TRY_CATCH_ERROR) {
                        failed = true;
                        error = value.error;
                        value = null;
                    } else {
                        succeeded = true;
                    }

                    if (promise === value) {
                        $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
                        return;
                    }

                } else {
                    value = detail;
                    succeeded = true;
                }

                if (promise._state !== $$$internal$$PENDING) {
                    // noop
                } else if (hasCallback && succeeded) {
                    $$$internal$$resolve(promise, value);
                } else if (failed) {
                    $$$internal$$reject(promise, error);
                } else if (settled === $$$internal$$FULFILLED) {
                    $$$internal$$fulfill(promise, value);
                } else if (settled === $$$internal$$REJECTED) {
                    $$$internal$$reject(promise, value);
                }
            }

            function $$$internal$$initializePromise(promise, resolver) {
                try {
                    resolver(function resolvePromise(value){
                        $$$internal$$resolve(promise, value);
                    }, function rejectPromise(reason) {
                        $$$internal$$reject(promise, reason);
                    });
                } catch(e) {
                    $$$internal$$reject(promise, e);
                }
            }

            function $$$enumerator$$makeSettledResult(state, position, value) {
                if (state === $$$internal$$FULFILLED) {
                    return {
                        state: 'fulfilled',
                        value: value
                    };
                } else {
                    return {
                        state: 'rejected',
                        reason: value
                    };
                }
            }

            function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
                this._instanceConstructor = Constructor;
                this.promise = new Constructor($$$internal$$noop, label);
                this._abortOnReject = abortOnReject;

                if (this._validateInput(input)) {
                    this._input     = input;
                    this.length     = input.length;
                    this._remaining = input.length;

                    this._init();

                    if (this.length === 0) {
                        $$$internal$$fulfill(this.promise, this._result);
                    } else {
                        this.length = this.length || 0;
                        this._enumerate();
                        if (this._remaining === 0) {
                            $$$internal$$fulfill(this.promise, this._result);
                        }
                    }
                } else {
                    $$$internal$$reject(this.promise, this._validationError());
                }
            }

            $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
                return $$utils$$isArray(input);
            };

            $$$enumerator$$Enumerator.prototype._validationError = function() {
                return new Error('Array Methods must be provided an Array');
            };

            $$$enumerator$$Enumerator.prototype._init = function() {
                this._result = new Array(this.length);
            };

            var $$$enumerator$$default = $$$enumerator$$Enumerator;

            $$$enumerator$$Enumerator.prototype._enumerate = function() {
                var length  = this.length;
                var promise = this.promise;
                var input   = this._input;

                for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
                    this._eachEntry(input[i], i);
                }
            };

            $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
                var c = this._instanceConstructor;
                if ($$utils$$isMaybeThenable(entry)) {
                    if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
                        entry._onerror = null;
                        this._settledAt(entry._state, i, entry._result);
                    } else {
                        this._willSettleAt(c.resolve(entry), i);
                    }
                } else {
                    this._remaining--;
                    this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
                }
            };

            $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
                var promise = this.promise;

                if (promise._state === $$$internal$$PENDING) {
                    this._remaining--;

                    if (this._abortOnReject && state === $$$internal$$REJECTED) {
                        $$$internal$$reject(promise, value);
                    } else {
                        this._result[i] = this._makeResult(state, i, value);
                    }
                }

                if (this._remaining === 0) {
                    $$$internal$$fulfill(promise, this._result);
                }
            };

            $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
                return value;
            };

            $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
                var enumerator = this;

                $$$internal$$subscribe(promise, undefined, function(value) {
                    enumerator._settledAt($$$internal$$FULFILLED, i, value);
                }, function(reason) {
                    enumerator._settledAt($$$internal$$REJECTED, i, reason);
                });
            };

            var $$promise$all$$default = function all(entries, label) {
                return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
            };

            var $$promise$race$$default = function race(entries, label) {
                /*jshint validthis:true */
                var Constructor = this;

                var promise = new Constructor($$$internal$$noop, label);

                if (!$$utils$$isArray(entries)) {
                    $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
                    return promise;
                }

                var length = entries.length;

                function onFulfillment(value) {
                    $$$internal$$resolve(promise, value);
                }

                function onRejection(reason) {
                    $$$internal$$reject(promise, reason);
                }

                for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
                    $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
                }

                return promise;
            };

            var $$promise$resolve$$default = function resolve(object, label) {
                /*jshint validthis:true */
                var Constructor = this;

                if (object && typeof object === 'object' && object.constructor === Constructor) {
                    return object;
                }

                var promise = new Constructor($$$internal$$noop, label);
                $$$internal$$resolve(promise, object);
                return promise;
            };

            var $$promise$reject$$default = function reject(reason, label) {
                /*jshint validthis:true */
                var Constructor = this;
                var promise = new Constructor($$$internal$$noop, label);
                $$$internal$$reject(promise, reason);
                return promise;
            };

            var $$es6$promise$promise$$counter = 0;

            function $$es6$promise$promise$$needsResolver() {
                throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
            }

            function $$es6$promise$promise$$needsNew() {
                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
            }

            var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

            /**
             Promise objects represent the eventual result of an asynchronous operation. The
             primary way of interacting with a promise is through its `then` method, which
             registers callbacks to receive either a promiseâs eventual value or the reason
             why the promise cannot be fulfilled.

             Terminology
             -----------

             - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
             - `thenable` is an object or function that defines a `then` method.
             - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
             - `exception` is a value that is thrown using the throw statement.
             - `reason` is a value that indicates why a promise was rejected.
             - `settled` the final resting state of a promise, fulfilled or rejected.

             A promise can be in one of three states: pending, fulfilled, or rejected.

             Promises that are fulfilled have a fulfillment value and are in the fulfilled
             state.  Promises that are rejected have a rejection reason and are in the
             rejected state.  A fulfillment value is never a thenable.

             Promises can also be said to *resolve* a value.  If this value is also a
             promise, then the original promise's settled state will match the value's
             settled state.  So a promise that *resolves* a promise that rejects will
             itself reject, and a promise that *resolves* a promise that fulfills will
             itself fulfill.


             Basic Usage:
             ------------

             ```js
             var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

             promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
             ```

             Advanced Usage:
             ---------------

             Promises shine when abstracting away asynchronous interactions such as
             `XMLHttpRequest`s.

             ```js
             function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

             getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
             ```

             Unlike callbacks, promises are great composable primitives.

             ```js
             Promise.all([
             getJSON('/posts'),
             getJSON('/comments')
             ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
             ```

             @class Promise
             @param {function} resolver
             Useful for tooling.
             @constructor
             */
            function $$es6$promise$promise$$Promise(resolver) {
                this._id = $$es6$promise$promise$$counter++;
                this._state = undefined;
                this._result = undefined;
                this._subscribers = [];

                if ($$$internal$$noop !== resolver) {
                    if (!$$utils$$isFunction(resolver)) {
                        $$es6$promise$promise$$needsResolver();
                    }

                    if (!(this instanceof $$es6$promise$promise$$Promise)) {
                        $$es6$promise$promise$$needsNew();
                    }

                    $$$internal$$initializePromise(this, resolver);
                }
            }

            $$es6$promise$promise$$Promise.all = $$promise$all$$default;
            $$es6$promise$promise$$Promise.race = $$promise$race$$default;
            $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
            $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;

            $$es6$promise$promise$$Promise.prototype = {
                constructor: $$es6$promise$promise$$Promise,

                /**
                 The primary way of interacting with a promise is through its `then` method,
                 which registers callbacks to receive either a promise's eventual value or the
                 reason why the promise cannot be fulfilled.

                 ```js
                 findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
                 ```

                 Chaining
                 --------

                 The return value of `then` is itself a promise.  This second, 'downstream'
                 promise is resolved with the return value of the first promise's fulfillment
                 or rejection handler, or rejected if the handler throws an exception.

                 ```js
                 findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

                 findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
                 ```
                 If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

                 ```js
                 findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
                 ```

                 Assimilation
                 ------------

                 Sometimes the value you want to propagate to a downstream promise can only be
                 retrieved asynchronously. This can be achieved by returning a promise in the
                 fulfillment or rejection handler. The downstream promise will then be pending
                 until the returned promise is settled. This is called *assimilation*.

                 ```js
                 findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
                 ```

                 If the assimliated promise rejects, then the downstream promise will also reject.

                 ```js
                 findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
                 ```

                 Simple Example
                 --------------

                 Synchronous Example

                 ```javascript
                 var result;

                 try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
                 ```

                 Errback Example

                 ```js
                 findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
                 ```

                 Promise Example;

                 ```javascript
                 findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
                 ```

                 Advanced Example
                 --------------

                 Synchronous Example

                 ```javascript
                 var author, books;

                 try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
                 ```

                 Errback Example

                 ```js

                 function foundBooks(books) {

      }

                 function failure(reason) {

      }

                 findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
                 ```

                 Promise Example;

                 ```javascript
                 findAuthor().
                 then(findBooksByAuthor).
                 then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
                 ```

                 @method then
                 @param {Function} onFulfilled
                 @param {Function} onRejected
                 Useful for tooling.
                 @return {Promise}
                 */
                then: function(onFulfillment, onRejection) {
                    var parent = this;
                    var state = parent._state;

                    if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {
                        return this;
                    }

                    var child = new this.constructor($$$internal$$noop);
                    var result = parent._result;

                    if (state) {
                        var callback = arguments[state - 1];
                        $$asap$$default(function(){
                            $$$internal$$invokeCallback(state, child, callback, result);
                        });
                    } else {
                        $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
                    }

                    return child;
                },

                /**
                 `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
                 as the catch block of a try/catch statement.

                 ```js
                 function findAuthor(){
        throw new Error('couldn't find that author');
      }

                 // synchronous
                 try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

                 // async with promises
                 findAuthor().catch(function(reason){
        // something went wrong
      });
                 ```

                 @method catch
                 @param {Function} onRejection
                 Useful for tooling.
                 @return {Promise}
                 */
                'catch': function(onRejection) {
                    return this.then(null, onRejection);
                }
            };

            var $$es6$promise$polyfill$$default = function polyfill() {
                var local;

                if (typeof global !== 'undefined') {
                    local = global;
                } else if (typeof window !== 'undefined' && window.document) {
                    local = window;
                } else {
                    local = self;
                }

                var es6PromiseSupport =
                    "Promise" in local &&
                        // Some of these methods are missing from
                        // Firefox/Chrome experimental implementations
                    "resolve" in local.Promise &&
                    "reject" in local.Promise &&
                    "all" in local.Promise &&
                    "race" in local.Promise &&
                        // Older version of the spec had a resolver object
                        // as the arg rather than a function
                    (function() {
                        var resolve;
                        new local.Promise(function(r) { resolve = r; });
                        return $$utils$$isFunction(resolve);
                    }());

                if (!es6PromiseSupport) {
                    local.Promise = $$es6$promise$promise$$default;
                }
            };

            var es6$promise$umd$$ES6Promise = {
                'Promise': $$es6$promise$promise$$default,
                'polyfill': $$es6$promise$polyfill$$default
            };

            /* global define:true module:true window: true */
            if (typeof define === 'function' && define['amd']) {
                define(function() { return es6$promise$umd$$ES6Promise; });
            } else if (typeof module !== 'undefined' && module['exports']) {
                module['exports'] = es6$promise$umd$$ES6Promise;
            } else if (typeof this !== 'undefined') {
                this['ES6Promise'] = es6$promise$umd$$ES6Promise;
            }
        }).call(this);
    }).call(this,require(1),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"1":1}],9:[function(require,module,exports){
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var undefined;

    var isArray = require(10);

    var isPlainObject = function isPlainObject(obj) {
        'use strict';
        if (!obj || toString.call(obj) !== '[object Object]') {
            return false;
        }

        var has_own_constructor = hasOwn.call(obj, 'constructor');
        var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
        // Not own constructor property must be Object
        if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        var key;
        for (key in obj) {}

        return key === undefined || hasOwn.call(obj, key);
    };

    module.exports = function extend() {
        'use strict';
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0],
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        } else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
            target = {};
        }

        for (; i < length; ++i) {
            options = arguments[i];
            // Only deal with non-null/undefined values
            if (options != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };


},{"10":10}],10:[function(require,module,exports){
    module.exports = Array.isArray || function (arr) {
        return Object.prototype.toString.call(arr) == '[object Array]';
    };

},{}],11:[function(require,module,exports){

    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;

    module.exports = function forEach (obj, fn, ctx) {
        if (toString.call(fn) !== '[object Function]') {
            throw new TypeError('iterator must be a function');
        }
        var l = obj.length;
        if (l === +l) {
            for (var i = 0; i < l; i++) {
                fn.call(ctx, obj[i], i, obj);
            }
        } else {
            for (var k in obj) {
                if (hasOwn.call(obj, k)) {
                    fn.call(ctx, obj[k], k, obj);
                }
            }
        }
    };


},{}],12:[function(require,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],13:[function(require,module,exports){
    (function (global){

        /**
         * Module exports.
         */

        module.exports = deprecate;

        /**
         * Mark that a method should not be used.
         * Returns a modified function which warns once by default.
         *
         * If `localStorage.noDeprecation = true` is set, then it is a no-op.
         *
         * If `localStorage.throwDeprecation = true` is set, then deprecated functions
         * will throw an Error when invoked.
         *
         * If `localStorage.traceDeprecation = true` is set, then deprecated functions
         * will invoke `console.trace()` instead of `console.error()`.
         *
         * @param {Function} fn - the function to deprecate
         * @param {String} msg - the string to print to the console when `fn` is invoked
         * @returns {Function} a new "deprecated" version of `fn`
         * @api public
         */

        function deprecate (fn, msg) {
            if (config('noDeprecation')) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (config('throwDeprecation')) {
                        throw new Error(msg);
                    } else if (config('traceDeprecation')) {
                        console.trace(msg);
                    } else {
                        console.warn(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        }

        /**
         * Checks `localStorage` for boolean values for the given `name`.
         *
         * @param {String} name
         * @returns {Boolean}
         * @api private
         */

        function config (name) {
            if (!global.localStorage) return false;
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
    (function (process){
        module.exports = AlgoliaSearch;

// default debug activated in dev environments
// this is triggered in package.json, using the envify transform
        if (process.env.NODE_ENV === 'development') {
            require(5).enable('algoliasearch*');
        }

        var debug = require(5)('algoliasearch:AlgoliaSearch');
        var deprecate = require(13);
        var foreach = require(11);

        /*
         * Algolia Search library initialization
         * https://www.algolia.com/
         *
         * @param {string} applicationID - Your applicationID, found in your dashboard
         * @param {string} apiKey - Your API key, found in your dashboard
         * @param {Object} [opts]
         * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds, another request will be issued after this timeout
         * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.
         *                                        Set to 'https:' to force using https. Default to document.location.protocol in browsers
         * @param {string[]} [opts.hosts=[
         *          this.applicationID + '-1.algolianet.com',
         *          this.applicationID + '-2.algolianet.com',
         *          this.applicationID + '-3.algolianet.com']
         *        ] - The hosts to use for Algolia Search API. If you provide them, you will no more benefit from our HA implementation
         */
        function AlgoliaSearch(applicationID, apiKey, opts) {
            var extend = require(9);

            var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';

            if (!applicationID) {
                throw new Error('algoliasearch: Please provide an application ID. ' + usage);
            }

            if (!apiKey) {
                throw new Error('algoliasearch: Please provide an API key. ' + usage);
            }

            this.applicationID = applicationID;
            this.apiKey = apiKey;

            var defaultHosts = [
                this.applicationID + '-1.algolianet.com',
                this.applicationID + '-2.algolianet.com',
                this.applicationID + '-3.algolianet.com'
            ];
            this.hosts = {
                read: [],
                write: []
            };

            this.hostIndex = {
                read: 0,
                write: 0
            };

            opts = opts || {};

            var protocol = opts.protocol || 'http:';
            var timeout = opts.timeout === undefined ? 2000 : opts.timeout;

            // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`
            // we also accept `http` and `https`. It's a common error.
            if (!/:$/.test(protocol)) {
                protocol = protocol + ':';
            }

            if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {
                throw new Error('algoliasearch: protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');
            }

            // no hosts given, add defaults
            if (!opts.hosts) {
                this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);
                this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);
            } else {
                this.hosts.read = extend([], opts.hosts);
                this.hosts.write = extend([], opts.hosts);
            }

            // add protocol and lowercase hosts
            this.hosts.read = map(this.hosts.read, prepareHost(protocol));
            this.hosts.write = map(this.hosts.write, prepareHost(protocol));
            this.requestTimeout = timeout;

            this.extraHeaders = [];
            this.cache = {};

            this._ua = opts._ua;
            this._useCache = opts._useCache === undefined ? true : opts._useCache;

            debug('init done, %j', this);
        }

        AlgoliaSearch.prototype = {
            /*
             * Delete an index
             *
             * @param indexName the name of index to delete
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer that contains the task ID
             */
            deleteIndex: function(indexName, callback) {
                return this._jsonRequest({ method: 'DELETE',
                    url: '/1/indexes/' + encodeURIComponent(indexName),
                    hostType: 'write',
                    callback: callback });
            },
            /**
             * Move an existing index.
             * @param srcIndexName the name of index to copy.
             * @param dstIndexName the new index name that will contains a copy of srcIndexName (destination will be overriten if it already exist).
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer that contains the task ID
             */
            moveIndex: function(srcIndexName, dstIndexName, callback) {
                var postObj = {operation: 'move', destination: dstIndexName};
                return this._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
                    body: postObj,
                    hostType: 'write',
                    callback: callback });

            },
            /**
             * Copy an existing index.
             * @param srcIndexName the name of index to copy.
             * @param dstIndexName the new index name that will contains a copy of srcIndexName (destination will be overriten if it already exist).
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer that contains the task ID
             */
            copyIndex: function(srcIndexName, dstIndexName, callback) {
                var postObj = {operation: 'copy', destination: dstIndexName};
                return this._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',
                    body: postObj,
                    hostType: 'write',
                    callback: callback });
            },
            /**
             * Return last log entries.
             * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
             * @param length Specify the maximum number of entries to retrieve starting at offset. Maximum allowed value: 1000.
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer that contains the task ID
             */
            getLogs: function(offset, length, callback) {
                if (arguments.length === 0 || typeof offset === 'function') {
                    // getLogs([cb])
                    callback = offset;
                    offset = 0;
                    length = 10;
                } else if (arguments.length === 1 || typeof length === 'function') {
                    // getLogs(1, [cb)]
                    callback = length;
                    length = 10;
                }

                return this._jsonRequest({ method: 'GET',
                    url: '/1/logs?offset=' + offset + '&length=' + length,
                    hostType: 'read',
                    callback: callback });
            },
            /*
             * List all existing indexes (paginated)
             *
             * @param page The page to retrieve, starting at 0.
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with index list
             */
            listIndexes: function(page, callback) {
                var params = '';

                if (page === undefined || typeof page === 'function') {
                    callback = page;
                } else {
                    params = '?page=' + page;
                }

                return this._jsonRequest({ method: 'GET',
                    url: '/1/indexes' + params,
                    hostType: 'read',
                    callback: callback });
            },

            /*
             * Get the index object initialized
             *
             * @param indexName the name of index
             * @param callback the result callback with one argument (the Index instance)
             */
            initIndex: function(indexName) {
                return new this.Index(this, indexName);
            },
            /*
             * List all existing user keys with their associated ACLs
             *
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            listUserKeys: function(callback) {
                return this._jsonRequest({ method: 'GET',
                    url: '/1/keys',
                    hostType: 'read',
                    callback: callback });
            },
            /*
             * Get ACL of a user key
             *
             * @param key
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            getUserKeyACL: function(key, callback) {
                return this._jsonRequest({ method: 'GET',
                    url: '/1/keys/' + key,
                    hostType: 'read',
                    callback: callback });
            },
            /*
             * Delete an existing user key
             * @param key
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            deleteUserKey: function(key, callback) {
                return this._jsonRequest({ method: 'DELETE',
                    url: '/1/keys/' + key,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Add an existing user key
             *
             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
             *   can contains the following values:
             *     - search: allow to search (https and http)
             *     - addObject: allows to add/update an object in the index (https only)
             *     - deleteObject : allows to delete an existing object (https only)
             *     - deleteIndex : allows to delete index content (https only)
             *     - settings : allows to get index settings (https only)
             *     - editSettings : allows to change index settings (https only)
             * @param {Object} [params] - Optionnal parameters to set for the key
             * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
             * @param {string[]} params.indexes - Allowed targeted indexes for this key
             * @param {Function} callback - The result callback called with two arguments
             *   error: null or Error('message')
             *   content: the server answer with user keys list
             * @return {Promise|undefined} Returns a promise if no callback given
             */
            addUserKey: function(acls, params, callback) {
                if (arguments.length === 1 || typeof params === 'function') {
                    callback = params;
                    params = null;
                }

                var postObj = {
                    acl: acls
                };

                if (params) {
                    postObj.validity = params.validity;
                    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
                    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
                    postObj.indexes = params.indexes;
                }

                return this._jsonRequest({
                    method: 'POST',
                    url: '/1/keys',
                    body: postObj,
                    hostType: 'write',
                    callback: callback
                });
            },
            /**
             * Add an existing user key
             * @deprecated Please use client.addUserKey()
             */
            addUserKeyWithValidity: deprecate(function(acls, params, callback) {
                return this.addUserKey(acls, params, callback);
            }, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addUserKey()')),

            /**
             * Update an existing user key
             * @param {string} key - The key to update
             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
             *   can contains the following values:
             *     - search: allow to search (https and http)
             *     - addObject: allows to add/update an object in the index (https only)
             *     - deleteObject : allows to delete an existing object (https only)
             *     - deleteIndex : allows to delete index content (https only)
             *     - settings : allows to get index settings (https only)
             *     - editSettings : allows to change index settings (https only)
             * @param {Object} [params] - Optionnal parameters to set for the key
             * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
             * @param {string[]} params.indexes - Allowed targeted indexes for this key
             * @param {Function} callback - The result callback called with two arguments
             *   error: null or Error('message')
             *   content: the server answer with user keys list
             * @return {Promise|undefined} Returns a promise if no callback given
             */
            updateUserKey: function(key, acls, params, callback) {
                if (arguments.length === 2 || typeof params === 'function') {
                    callback = params;
                    params = null;
                }

                var putObj = {
                    acl: acls
                };

                if (params) {
                    putObj.validity = params.validity;
                    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
                    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
                    putObj.indexes = params.indexes;
                }

                return this._jsonRequest({
                    method: 'PUT',
                    url: '/1/keys/' + key,
                    body: putObj,
                    hostType: 'write',
                    callback: callback
                });
            },

            /**
             * Set the extra security tagFilters header
             * @param {string|array} tags The list of tags defining the current security filters
             */
            setSecurityTags: function(tags) {
                if (Object.prototype.toString.call(tags) === '[object Array]') {
                    var strTags = [];
                    for (var i = 0; i < tags.length; ++i) {
                        if (Object.prototype.toString.call(tags[i]) === '[object Array]') {
                            var oredTags = [];
                            for (var j = 0; j < tags[i].length; ++j) {
                                oredTags.push(tags[i][j]);
                            }
                            strTags.push('(' + oredTags.join(',') + ')');
                        } else {
                            strTags.push(tags[i]);
                        }
                    }
                    tags = strTags.join(',');
                }

                this.securityTags = tags;
            },

            /**
             * Set the extra user token header
             * @param {string} userToken The token identifying a uniq user (used to apply rate limits)
             */
            setUserToken: function(userToken) {
                this.userToken = userToken;
            },

            /**
             * Initialize a new batch of search queries
             * @deprecated use client.search()
             */
            startQueriesBatch: deprecate(function() {
                this._batch = [];
            }, deprecatedMessage('client.startQueriesBatch()', 'client.search()')),

            /**
             * Add a search query in the batch
             * @deprecated use client.search()
             */
            addQueryInBatch: deprecate(function(indexName, query, args) {
                this._batch.push({
                    indexName: indexName,
                    query: query,
                    params: args
                });
            }, deprecatedMessage('client.addQueryInBatch()', 'client.search()')),

            /**
             * Clear all queries in client's cache
             * @return undefined
             */
            clearCache: function() {
                this.cache = {};
            },

            /**
             * Launch the batch of queries using XMLHttpRequest.
             * @deprecated use client.search()
             */
            sendQueriesBatch: deprecate(function(callback) {
                return this.search(this._batch, callback);
            }, deprecatedMessage('client.sendQueriesBatch()', 'client.search()')),

            /**
             * Set the number of milliseconds a request can take before automatically being terminated.
             *
             * @param {Number} milliseconds
             */
            setRequestTimeout: function(milliseconds) {
                if (milliseconds) {
                    this.requestTimeout = parseInt(milliseconds, 10);
                }
            },

            /**
             * Search through multiple indices at the same time
             * @param  {Object[]}   queries  An array of queries you want to run.
             * @param {string} queries[].indexName The index name you want to target
             * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`
             * @param {Object} queries[].params Any search param like hitsPerPage, ..
             * @param  {Function} callback Callback to be called
             * @return {Promise|undefined} Returns a promise if no callback given
             */
            search: function(queries, callback) {
                var client = this;

                var postObj = {
                    requests: map(queries, function prepareRequest(query) {
                        var params = '';

                        // allow query.query
                        // so we are mimicing the index.search(query, params) method
                        // {indexName:, query:, params:}
                        if (query.query !== undefined) {
                            params += 'query=' + encodeURIComponent(query.query)
                        }

                        return {
                            indexName: query.indexName,
                            params: client._getSearchParams(query.params, params)
                        };
                    })
                };

                return this._jsonRequest({
                    cache: this.cache,
                    method: 'POST',
                    url: '/1/indexes/*/queries',
                    body: postObj,
                    hostType: 'read',
                    callback: callback
                });
            },

            // environment specific methods
            destroy: notImplemented,
            enableRateLimitForward: notImplemented,
            disableRateLimitForward: notImplemented,
            useSecuredAPIKey: notImplemented,
            disableSecuredAPIKey: notImplemented,
            generateSecuredApiKey: notImplemented,
            /*
             * Index class constructor.
             * You should not use this method directly but use initIndex() function
             */
            Index: function(algoliasearch, indexName) {
                this.indexName = indexName;
                this.as = algoliasearch;
                this.typeAheadArgs = null;
                this.typeAheadValueOption = null;

                // make sure every index instance has it's own cache
                this.cache = {};
            },
            /**
             * Add an extra field to the HTTP request
             *
             * @param name the header field name
             * @param value the header field value
             */
            setExtraHeader: function(name, value) {
                this.extraHeaders.push({ name: name.toLowerCase(), value: value});
            },

            _sendQueriesBatch: function(params, callback) {
                return this._jsonRequest({ cache: this.cache,
                    method: 'POST',
                    url: '/1/indexes/*/queries',
                    body: params,
                    hostType: 'read',
                    fallback: {
                        method: 'GET',
                        url: '/1/indexes/*',
                        body: {params: (function() {
                            var reqParams = '';
                            for (var i = 0; i < params.requests.length; ++i) {
                                var q = '/1/indexes/' + encodeURIComponent(params.requests[i].indexName) + '?' + params.requests[i].params;
                                reqParams += i + '=' + encodeURIComponent(q) + '&';
                            }
                            return reqParams;
                        }())}
                    },
                    callback: callback
                });
            },
            /*
             * Wrapper that try all hosts to maximize the quality of service
             */
            _jsonRequest: function(opts) {
                var requestDebug = require(5)('algoliasearch:AlgoliaSearch:_jsonRequest:' + opts.url);

                requestDebug('start: body: %j', opts.body);

                var cache = opts.cache;
                var cacheID;
                var client = this;
                var tries = 0;
                var usingFallback = false;

                if (client._useCache) {
                    cacheID = opts.url;
                }

                // as we sometime use POST requests to pass parameters (like query='aa'),
                // the cacheID must also include the body to be different between calls
                if (client._useCache && opts.body !== undefined) {
                    cacheID += '_body_' + JSON.stringify(opts.body);
                }

                if (opts.cache !== undefined) {
                    requestDebug('Will use cache if any');
                }

                function doRequest(requester, reqOpts) {
                    // handle cache existence
                    if (client._useCache && cache && cache[cacheID] !== undefined) {
                        requestDebug('serving response from cache, body: %j', cache[cacheID]);
                        return client._promise.resolve(cache[cacheID]);
                    }

                    if (tries >= client.hosts[opts.hostType].length) {
                        if (!opts.fallback || !client._request.fallback || usingFallback) {
                            // could not get a response even using the fallback if one was available
                            return client._promise.reject(new Error(
                                'Cannot connect to the AlgoliaSearch API.' +
                                ' Send an email to support@algolia.com to report and resolve the issue.'
                            ));
                        }

                        tries = 0;
                        reqOpts.method = opts.fallback.method;
                        reqOpts.url = opts.fallback.url;
                        reqOpts.body = opts.fallback.body;
                        reqOpts.timeout = client.requestTimeout * (tries + 1);
                        client.hostIndex[opts.hostType] = 0;
                        client.useFallback = true; // now we will only use JSONP, even on future requests
                        usingFallback = true; // the current request is now using fallback
                        return doRequest(client._request.fallback, reqOpts);
                    }

                    requestDebug('request: %j', reqOpts);

                    // `requester` is any of this._request or this._request.fallback
                    // thus it needs to be called using the client as context
                    return requester.call(client,
                        // http(s)://currenthost/url(?qs)
                        client.hosts[opts.hostType][client.hostIndex[opts.hostType]] + reqOpts.url, {
                            body: reqOpts.body,
                            method: reqOpts.method,
                            headers: client._computeRequestHeaders(),
                            timeout: reqOpts.timeout
                        }
                    )
                        .then(function success(httpResponse) {
                            // timeout case, retry immediately
                            if (httpResponse instanceof Error) {
                                requestDebug('error: %s', httpResponse.message);
                                return retryRequest();
                            }

                            requestDebug('response: %j', httpResponse);

                            var status =
                                // When in browser mode, using XDR or JSONP
                                // We rely on our own API response `status`, only
                                // provided when an error occurs, we also expect a .message along
                                // Otherwise, it could be a `waitTask` status, that's the only
                                // case where we have a response.status that's not the http statusCode
                                httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||

                                    // this is important to check the request statusCode AFTER the body eventual
                                    // statusCode because some implementations (jQuery XDomainRequest transport) may
                                    // send statusCode 200 while we had an error
                                httpResponse.statusCode ||

                                    // When in browser mode, using XDR or JSONP
                                    // we default to success when no error (no response.status && response.message)
                                    // If there was a JSON.parse() error then body is null and it fails
                                httpResponse && httpResponse.body && 200;

                            var ok = status === 200 || status === 201;
                            var retry = !ok && Math.floor(status / 100) !== 4 && Math.floor(status / 100) !== 1;

                            if (client._useCache && ok && cache) {
                                cache[cacheID] = httpResponse.body;
                            }

                            if (ok) {
                                return httpResponse.body;
                            }

                            if (retry) {
                                return retryRequest();
                            }

                            var unrecoverableError = new Error(
                                httpResponse.body && httpResponse.body.message || 'Unknown error'
                            );

                            return client._promise.reject(unrecoverableError);
                        }, tryFallback);

                    function retryRequest() {
                        client.hostIndex[opts.hostType] = ++client.hostIndex[opts.hostType] % client.hosts[opts.hostType].length;
                        tries += 1;
                        reqOpts.timeout = client.requestTimeout * (tries + 1);
                        return doRequest(requester, reqOpts);
                    }

                    function tryFallback(err) {
                        // error cases:
                        //  While not in fallback mode:
                        //    - CORS not supported
                        //    - network error
                        //  While in fallback mode:
                        //    - timeout
                        //    - network error
                        //    - badly formatted JSONP (script loaded, did not call our callback)
                        //  In both cases:
                        //    - uncaught exception occurs (TypeError)
                        requestDebug('error: %s, stack: %s', err.message, err.stack);

                        // we were not using the fallback, try now
                        // if we are switching to fallback right now, set tries to maximum
                        if (!client.useFallback) {
                            // next time doRequest is called, simulate we tried all hosts,
                            // this will force to use the fallback
                            tries = client.hosts[opts.hostType].length;
                        } else {
                            // we were already using the fallback, but something went wrong (script error)
                            client.hostIndex[opts.hostType] = ++client.hostIndex[opts.hostType] % client.hosts[opts.hostType].length;
                            tries += 1;
                        }

                        return doRequest(requester, reqOpts);
                    }
                }

                // we can use a fallback if forced AND fallback parameters are available
                var useFallback = client.useFallback && opts.fallback;
                var requestOptions = useFallback ? opts.fallback : opts;

                var promise = doRequest(
                    // set the requester
                    useFallback ? client._request.fallback : client._request, {
                        url: requestOptions.url,
                        method: requestOptions.method,
                        body: requestOptions.body,
                        timeout: client.requestTimeout * (tries + 1)
                    }
                );

                // either we have a callback
                // either we are using promises
                if (opts.callback) {
                    promise.then(function okCb(content) {
                        setTimeout(function() {
                            opts.callback(null, content);
                        }, 0);
                    }, function nookCb(err) {
                        setTimeout(function() {
                            opts.callback(err);
                        }, 0);
                    });
                } else {
                    return promise;
                }
            },

            /*
             * Transform search param object in query string
             */
            _getSearchParams: function(args, params) {
                if (this._isUndefined(args) || args === null) {
                    return params;
                }
                for (var key in args) {
                    if (key !== null && args.hasOwnProperty(key)) {
                        params += params === '' ? '' : '&';
                        params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? JSON.stringify(args[key]) : args[key]);
                    }
                }
                return params;
            },

            _isUndefined: function(obj) {
                return obj === void 0;
            },

            _computeRequestHeaders: function() {
                var requestHeaders = {
                    'x-algolia-api-key': this.apiKey,
                    'x-algolia-application-id': this.applicationID,
                    'x-user-agent': this._ua
                };

                if (this.userToken) {
                    requestHeaders['x-algolia-usertoken'] = this.userToken;
                }

                if (this.securityTags) {
                    requestHeaders['x-algolia-tagfilters'] = this.securityTags;
                }

                if (this.extraHeaders) {
                    foreach(this.extraHeaders, function addToRequestHeaders(header) {
                        requestHeaders[header.name] = header.value;
                    });
                }

                return requestHeaders;
            }
        };

        /*
         * Contains all the functions related to one index
         * You should use AlgoliaSearch.initIndex(indexName) to retrieve this object
         */
        AlgoliaSearch.prototype.Index.prototype = {
            /*
             * Clear all queries in cache
             */
            clearCache: function() {
                this.cache = {};
            },
            /*
             * Add an object in this index
             *
             * @param content contains the javascript object to add inside the index
             * @param objectID (optional) an objectID you want to attribute to this object
             * (if the attribute already exist the old object will be overwrite)
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that contains 3 elements: createAt, taskId and objectID
             */
            addObject: function(content, objectID, callback) {
                var indexObj = this;

                if (arguments.length === 1 || typeof objectID === 'function') {
                    callback = objectID;
                    objectID = undefined;
                }

                return this.as._jsonRequest({
                    method: objectID !== undefined ?
                        'PUT' : // update or create
                        'POST', // create (API generates an objectID)
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + // create
                    (objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create
                    body: content,
                    hostType: 'write',
                    callback: callback
                });
            },
            /*
             * Add several objects
             *
             * @param objects contains an array of objects to add
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that updateAt and taskID
             */
            addObjects: function(objects, callback) {
                var indexObj = this;
                var postObj = {requests: []};
                for (var i = 0; i < objects.length; ++i) {
                    var request = { action: 'addObject',
                        body: objects[i] };
                    postObj.requests.push(request);
                }
                return this.as._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
                    body: postObj,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Get an object from this index
             *
             * @param objectID the unique identifier of the object to retrieve
             * @param attrs (optional) if set, contains the array of attribute names to retrieve
             * @param callback (optional) the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the object to retrieve or the error message if a failure occured
             */
            getObject: function(objectID, attrs, callback) {
                var indexObj = this;

                if (arguments.length === 1 || typeof attrs === 'function') {
                    callback = attrs;
                    attrs = undefined;
                }

                var params = '';
                if (attrs !== undefined) {
                    params = '?attributes=';
                    for (var i = 0; i < attrs.length; ++i) {
                        if (i !== 0) {
                            params += ',';
                        }
                        params += attrs[i];
                    }
                }

                return this.as._jsonRequest({
                    method: 'GET',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,
                    hostType: 'read',
                    callback: callback
                });
            },

            /*
             * Get several objects from this index
             *
             * @param objectIDs the array of unique identifier of objects to retrieve
             */
            getObjects: function(objectIDs, callback) {
                var indexObj = this;

                var body = {
                    requests: map(objectIDs, function prepareRequest(objectID) {
                        return {
                            'indexName': indexObj.indexName,
                            'objectID': objectID
                        };
                    })
                };

                return this.as._jsonRequest({
                    method: 'POST',
                    url: '/1/indexes/*/objects',
                    hostType: 'read',
                    body: body,
                    callback: callback
                });
            },

            /*
             * Update partially an object (only update attributes passed in argument)
             *
             * @param partialObject contains the javascript attributes to override, the
             *  object must contains an objectID attribute
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that contains 3 elements: createAt, taskId and objectID
             */
            partialUpdateObject: function(partialObject, callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial',
                    body: partialObject,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Partially Override the content of several objects
             *
             * @param objects contains an array of objects to update (each object must contains a objectID attribute)
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that updateAt and taskID
             */
            partialUpdateObjects: function(objects, callback) {
                var indexObj = this;
                var postObj = {requests: []};
                for (var i = 0; i < objects.length; ++i) {
                    var request = { action: 'partialUpdateObject',
                        objectID: objects[i].objectID,
                        body: objects[i] };
                    postObj.requests.push(request);
                }
                return this.as._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
                    body: postObj,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Override the content of object
             *
             * @param object contains the javascript object to save, the object must contains an objectID attribute
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that updateAt and taskID
             */
            saveObject: function(object, callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'PUT',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),
                    body: object,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Override the content of several objects
             *
             * @param objects contains an array of objects to update (each object must contains a objectID attribute)
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that updateAt and taskID
             */
            saveObjects: function(objects, callback) {
                var indexObj = this;
                var postObj = {requests: []};
                for (var i = 0; i < objects.length; ++i) {
                    var request = { action: 'updateObject',
                        objectID: objects[i].objectID,
                        body: objects[i] };
                    postObj.requests.push(request);
                }
                return this.as._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
                    body: postObj,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Delete an object from the index
             *
             * @param objectID the unique identifier of object to delete
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that contains 3 elements: createAt, taskId and objectID
             */
            deleteObject: function(objectID, callback) {
                if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {
                    var err = new Error('Cannot delete an object without an objectID');
                    callback = objectID;
                    if (typeof callback === 'function') {
                        return callback(err);
                    }

                    return this.as._promise.reject(err);
                }

                var indexObj = this;
                return this.as._jsonRequest({ method: 'DELETE',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Delete several objects from an index
             *
             * @param objectIDs contains an array of objectID to delete
             * @param callback (optional) the result callback called with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that contains 3 elements: createAt, taskId and objectID
             */
            deleteObjects: function(objectIDs, callback) {
                var indexObj = this;
                var postObj = {
                    requests: map(objectIDs, function prepareRequest(objectID) {
                        return {
                            action: 'deleteObject',
                            objectID: objectID,
                            body: {
                                objectID: objectID
                            }
                        };
                    })
                };

                return this.as._jsonRequest({
                    method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',
                    body: postObj,
                    hostType: 'write',
                    callback: callback
                });
            },
            /*
             * Delete all objects matching a query
             *
             * @param query the query string
             * @param params the optional query parameters
             * @param callback (optional) the result callback called with one argument
             *  error: null or Error('message')
             */
            deleteByQuery: function(query, params, callback) {
                var indexObj = this;

                if (arguments.length === 1 || typeof params === 'function') {
                    callback = params;
                    params = {};
                }

                params.attributesToRetrieve = 'objectID';
                params.hitsPerPage = 1000;

                // when deleting, we should never use cache to get the
                // search results
                this.clearCache();

                // there's a problem in how we use the promise chain,
                // see how waitTask is done
                var promise = this
                    .search(query, params)
                    .then(stopOrDelete);

                function stopOrDelete(searchContent) {
                    // stop here
                    if (searchContent.nbHits === 0) {
                        // return indexObj.as._request.resolve();
                        return searchContent;
                    }

                    // continue and do a recursive call
                    var objectIDs = map(searchContent.hits, function getObjectID(object) {
                        return object.objectID;
                    });

                    return indexObj
                        .deleteObjects(objectIDs)
                        .then(waitTask)
                        .then(deleteByQuery);
                }

                function waitTask(deleteObjectsContent) {
                    return indexObj.waitTask(deleteObjectsContent.taskID);
                }

                function deleteByQuery() {
                    return indexObj.deleteByQuery(query, params);
                }

                if (!callback) {
                    return promise;
                }

                promise.then(success, failure);

                function success() {
                    setTimeout(function() {
                        callback(null);
                    }, 0);
                }

                function failure(err) {
                    setTimeout(function() {
                        callback(err);
                    }, 0);
                }
            },
            /*
             * Search inside the index using XMLHttpRequest request (Using a POST query to
             * minimize number of OPTIONS queries: Cross-Origin Resource Sharing).
             *
             * @param query the full text query
             * @param args (optional) if set, contains an object with query parameters:
             * - page: (integer) Pagination parameter used to select the page to retrieve.
             *                   Page is zero-based and defaults to 0. Thus, to retrieve the 10th page you need to set page=9
             * - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.
             * - attributesToRetrieve: a string that contains the list of object attributes you want to retrieve (let you minimize the answer size).
             *   Attributes are separated with a comma (for example "name,address").
             *   You can also use an array (for example ["name","address"]).
             *   By default, all attributes are retrieved. You can also use '*' to retrieve all values when an attributesToRetrieve setting is specified for your index.
             * - attributesToHighlight: a string that contains the list of attributes you want to highlight according to the query.
             *   Attributes are separated by a comma. You can also use an array (for example ["name","address"]).
             *   If an attribute has no match for the query, the raw value is returned. By default all indexed text attributes are highlighted.
             *   You can use `*` if you want to highlight all textual attributes. Numerical attributes are not highlighted.
             *   A matchLevel is returned for each highlighted attribute and can contain:
             *      - full: if all the query terms were found in the attribute,
             *      - partial: if only some of the query terms were found,
             *      - none: if none of the query terms were found.
             * - attributesToSnippet: a string that contains the list of attributes to snippet alongside the number of words to return (syntax is `attributeName:nbWords`).
             *    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).
             *    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']). By default no snippet is computed.
             * - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word. Defaults to 3.
             * - minWordSizefor2Typos: the minimum number of characters in a query word to accept two typos in this word. Defaults to 7.
             * - getRankingInfo: if set to 1, the result hits will contain ranking information in _rankingInfo attribute.
             * - aroundLatLng: search for entries around a given latitude/longitude (specified as two floats separated by a comma).
             *   For example aroundLatLng=47.316669,5.016670).
             *   You can specify the maximum distance in meters with the aroundRadius parameter (in meters) and the precision for ranking with aroundPrecision
             *   (for example if you set aroundPrecision=100, two objects that are distant of less than 100m will be considered as identical for "geo" ranking parameter).
             *   At indexing, you should specify geoloc of an object with the _geoloc attribute (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
             * - insideBoundingBox: search entries inside a given area defined by the two extreme points of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).
             *   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).
             *   At indexing, you should specify geoloc of an object with the _geoloc attribute (in the form {"_geoloc":{"lat":48.853409, "lng":2.348800}})
             * - numericFilters: a string that contains the list of numeric filters you want to apply separated by a comma.
             *   The syntax of one filter is `attributeName` followed by `operand` followed by `value`. Supported operands are `<`, `<=`, `=`, `>` and `>=`.
             *   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.
             *   You can also use an array (for example numericFilters: ["price>100","price<1000"]).
             * - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.
             *   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).
             *   You can also use an array, for example tagFilters: ["tag1",["tag2","tag3"]] means tag1 AND (tag2 OR tag3).
             *   At indexing, tags should be added in the _tags** attribute of objects (for example {"_tags":["tag1","tag2"]}).
             * - facetFilters: filter the query by a list of facets.
             *   Facets are separated by commas and each facet is encoded as `attributeName:value`.
             *   For example: `facetFilters=category:Book,author:John%20Doe`.
             *   You can also use an array (for example `["category:Book","author:John%20Doe"]`).
             * - facets: List of object attributes that you want to use for faceting.
             *   Comma separated list: `"category,author"` or array `['category','author']`
             *   Only attributes that have been added in **attributesForFaceting** index setting can be used in this parameter.
             *   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.
             * - queryType: select how the query words are interpreted, it can be one of the following value:
             *    - prefixAll: all query words are interpreted as prefixes,
             *    - prefixLast: only the last word is interpreted as a prefix (default behavior),
             *    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
             * - optionalWords: a string that contains the list of words that should be considered as optional when found in the query.
             *   Comma separated and array are accepted.
             * - distinct: If set to 1, enable the distinct feature (disabled by default) if the attributeForDistinct index setting is set.
             *   This feature is similar to the SQL "distinct" keyword: when enabled in a query with the distinct=1 parameter,
             *   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.
             *   For example, if the chosen attribute is show_name and several hits have the same value for show_name, then only the best
             *   one is kept and others are removed.
             * - restrictSearchableAttributes: List of attributes you want to use for textual search (must be a subset of the attributesToIndex index setting)
             * either comma separated or as an array
             * @param callback the result callback called with two arguments:
             *  error: null or Error('message'). If false, the content contains the error.
             *  content: the server answer that contains the list of results.
             */
            search: function(query, args, callback) {
                // warn V2 users on how to search
                if (typeof query === 'function' && typeof args === 'object' ||
                    typeof callback === 'object') {
                    // .search(query, params, cb)
                    // .search(cb, params)
                    throw new Error('algoliasearch: index.search usage is index.search(query, params, cb)');
                }

                if (arguments.length === 0 || typeof query === 'function') {
                    // .search(), .search(cb)
                    callback = query;
                    query = '';
                } else if (arguments.length === 1 || typeof args === 'function') {
                    // .search(query/args), .search(query, cb)
                    callback = args;
                    args = undefined;
                }

                // .search(args), careful: typeof null === 'object'
                if (typeof query === 'object' && query !== null) {
                    args = query;
                    query = undefined;
                } else if (query === undefined || query === null) { // .search(undefined/null)
                    query = '';
                }

                var params = '';

                if (query !== undefined) {
                    params += 'query=' + encodeURIComponent(query);
                }

                if (args !== undefined) {
                    params = this.as._getSearchParams(args, params);
                }

                return this._search(params, callback);
            },

            /*
             * Browse all index content
             *
             * @param page Pagination parameter used to select the page to retrieve.
             *             Page is zero-based and defaults to 0. Thus, to retrieve the 10th page you need to set page=9
             * @param hitsPerPage: Pagination parameter used to select the number of hits per page. Defaults to 1000.
             * @param callback the result callback called with two arguments:
             *  error: null or Error('message'). If false, the content contains the error.
             *  content: the server answer that contains the list of results.
             */
            browse: function(page, hitsPerPage, callback) {
                var indexObj = this;

                if (arguments.length === 1 || typeof hitsPerPage === 'function') {
                    callback = hitsPerPage;
                    hitsPerPage = undefined;
                }

                var params = '?page=' + page;
                if (!this.as._isUndefined(hitsPerPage)) {
                    params += '&hitsPerPage=' + hitsPerPage;
                }
                return this.as._jsonRequest({ method: 'GET',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse' + params,
                    hostType: 'read',
                    callback: callback });
            },

            /*
             * Get a Typeahead.js adapter
             * @param searchParams contains an object with query parameters (see search for details)
             */
            ttAdapter: function(params) {
                var self = this;
                return function(query, cb) {
                    self.search(query, params, function(err, content) {
                        if (err) {
                            cb(err);
                            return;
                        }

                        cb(content.hits);
                    });
                };
            },

            /*
             * Wait the publication of a task on the server.
             * All server task are asynchronous and you can check with this method that the task is published.
             *
             * @param taskID the id of the task returned by server
             * @param callback the result callback with with two arguments:
             *  error: null or Error('message')
             *  content: the server answer that contains the list of results
             */
            waitTask: function(taskID, callback) {
                // waitTask() must be handled differently from other methods,
                // it's a recursive method using a timeout
                var indexObj = this;

                var promise = this.as._jsonRequest({
                    method: 'GET',
                    hostType: 'read',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID
                }).then(function success(content) {
                    if (content.status !== 'published') {
                        return indexObj.as._promise.delay(100).then(function() {
                            // do not forward the callback, we want the promise
                            // on next iteration
                            return indexObj.waitTask(taskID);
                        });
                    }

                    return content;
                });

                if (!callback) {
                    return promise;
                }

                promise.then(successCb, failureCb);

                function successCb(content) {
                    setTimeout(function() {
                        callback(null, content);
                    }, 0);
                }

                function failureCb(err) {
                    setTimeout(function() {
                        callback(err);
                    }, 0);
                }
            },

            /*
             * This function deletes the index content. Settings and index specific API keys are kept untouched.
             *
             * @param callback (optional) the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the settings object or the error message if a failure occured
             */
            clearIndex: function(callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Get settings of this index
             *
             * @param callback (optional) the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the settings object or the error message if a failure occured
             */
            getSettings: function(callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'GET',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings',
                    hostType: 'read',
                    callback: callback });
            },

            /*
             * Set settings for this index
             *
             * @param settigns the settings object that can contains :
             * - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).
             * - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).
             * - hitsPerPage: (integer) the number of hits per page (default = 10).
             * - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.
             *   If set to null, all attributes are retrieved.
             * - attributesToHighlight: (array of strings) default list of attributes to highlight.
             *   If set to null, all indexed attributes are highlighted.
             * - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number of words to return (syntax is attributeName:nbWords).
             *   By default no snippet is computed. If set to null, no snippet is computed.
             * - attributesToIndex: (array of strings) the list of fields you want to index.
             *   If set to null, all textual and numerical attributes of your objects are indexed, but you should update it to get optimal results.
             *   This parameter has two important uses:
             *     - Limit the attributes to index: For example if you store a binary image in base64, you want to store it and be able to
             *       retrieve it but you don't want to search in the base64 string.
             *     - Control part of the ranking*: (see the ranking parameter for full explanation) Matches in attributes at the beginning of
             *       the list will be considered more important than matches in attributes further down the list.
             *       In one attribute, matching text at the beginning of the attribute will be considered more important than text after, you can disable
             *       this behavior if you add your attribute inside `unordered(AttributeName)`, for example attributesToIndex: ["title", "unordered(text)"].
             * - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.
             *   All strings in the attribute selected for faceting are extracted and added as a facet. If set to null, no attribute is used for faceting.
             * - attributeForDistinct: (string) The attribute name used for the Distinct feature. This feature is similar to the SQL "distinct" keyword: when enabled
             *   in query with the distinct=1 parameter, all hits containing a duplicate value for this attribute are removed from results.
             *   For example, if the chosen attribute is show_name and several hits have the same value for show_name, then only the best one is kept and others are removed.
             * - ranking: (array of strings) controls the way results are sorted.
             *   We have six available criteria:
             *    - typo: sort according to number of typos,
             *    - geo: sort according to decreassing distance when performing a geo-location based search,
             *    - proximity: sort according to the proximity of query words in hits,
             *    - attribute: sort according to the order of attributes defined by attributesToIndex,
             *    - exact:
             *        - if the user query contains one word: sort objects having an attribute that is exactly the query word before others.
             *          For example if you search for the "V" TV show, you want to find it with the "V" query and avoid to have all popular TV
             *          show starting by the v letter before it.
             *        - if the user query contains multiple words: sort according to the number of words that matched exactly (and not as a prefix).
             *    - custom: sort according to a user defined formula set in **customRanking** attribute.
             *   The standard order is ["typo", "geo", "proximity", "attribute", "exact", "custom"]
             * - customRanking: (array of strings) lets you specify part of the ranking.
             *   The syntax of this condition is an array of strings containing attributes prefixed by asc (ascending order) or desc (descending order) operator.
             *   For example `"customRanking" => ["desc(population)", "asc(name)"]`
             * - queryType: Select how the query words are interpreted, it can be one of the following value:
             *   - prefixAll: all query words are interpreted as prefixes,
             *   - prefixLast: only the last word is interpreted as a prefix (default behavior),
             *   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.
             * - highlightPreTag: (string) Specify the string that is inserted before the highlighted parts in the query result (default to "<em>").
             * - highlightPostTag: (string) Specify the string that is inserted after the highlighted parts in the query result (default to "</em>").
             * - optionalWords: (array of strings) Specify a list of words that should be considered as optional when found in the query.
             * @param callback (optional) the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer or the error message if a failure occured
             */
            setSettings: function(settings, callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'PUT',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings',
                    hostType: 'write',
                    body: settings,
                    callback: callback });
            },
            /*
             * List all existing user keys associated to this index
             *
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            listUserKeys: function(callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'GET',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',
                    hostType: 'read',
                    callback: callback });
            },
            /*
             * Get ACL of a user key associated to this index
             *
             * @param key
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            getUserKeyACL: function(key, callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'GET',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
                    hostType: 'read',
                    callback: callback });
            },
            /*
             * Delete an existing user key associated to this index
             *
             * @param key
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            deleteUserKey: function(key, callback) {
                var indexObj = this;
                return this.as._jsonRequest({ method: 'DELETE',
                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,
                    hostType: 'write',
                    callback: callback });
            },
            /*
             * Add an existing user key associated to this index
             *
             * @param acls the list of ACL for this key. Defined by an array of strings that
             * can contains the following values:
             *   - search: allow to search (https and http)
             *   - addObject: allows to add/update an object in the index (https only)
             *   - deleteObject : allows to delete an existing object (https only)
             *   - deleteIndex : allows to delete index content (https only)
             *   - settings : allows to get index settings (https only)
             *   - editSettings : allows to change index settings (https only)
             * @param callback the result callback called with two arguments
             *  error: null or Error('message')
             *  content: the server answer with user keys list
             */
            addUserKey: function(acls, params, callback) {
                if (arguments.length === 1 || typeof params === 'function') {
                    callback = params;
                    params = null;
                }

                var postObj = {
                    acl: acls
                };

                if (params) {
                    postObj.validity = params.validity;
                    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
                    postObj.maxHitsPerQuery = params.maxHitsPerQuery;
                }

                return this.as._jsonRequest({
                    method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',
                    body: postObj,
                    hostType: 'write',
                    callback: callback
                });
            },

            /**
             * Add an existing user key associated to this index
             * @deprecated use index.addUserKey()
             */
            addUserKeyWithValidity: deprecate(function(acls, params, callback) {
                return this.addUserKey(acls, params, callback);
            }, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addUserKey()')),

            /**
             * Update an existing user key associated to this index
             * @param {string} key - The key to update
             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that
             *   can contains the following values:
             *     - search: allow to search (https and http)
             *     - addObject: allows to add/update an object in the index (https only)
             *     - deleteObject : allows to delete an existing object (https only)
             *     - deleteIndex : allows to delete index content (https only)
             *     - settings : allows to get index settings (https only)
             *     - editSettings : allows to change index settings (https only)
             * @param {Object} [params] - Optionnal parameters to set for the key
             * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)
             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour
             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call
             * @param {Function} callback - The result callback called with two arguments
             *   error: null or Error('message')
             *   content: the server answer with user keys list
             * @return {Promise|undefined} Returns a promise if no callback given
             */
            updateUserKey: function(key, acls, params, callback) {
                if (arguments.length === 2 || typeof params === 'function') {
                    callback = params;
                    params = null;
                }

                var putObj = {
                    acl: acls
                };

                if (params) {
                    putObj.validity = params.validity;
                    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;
                    putObj.maxHitsPerQuery = params.maxHitsPerQuery;
                }

                return this.as._jsonRequest({
                    method: 'PUT',
                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,
                    body: putObj,
                    hostType: 'write',
                    callback: callback
                });
            },

            _search: function(params, callback) {
                return this.as._jsonRequest({ cache: this.cache,
                    method: 'POST',
                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',
                    body: {params: params},
                    hostType: 'read',
                    fallback: {
                        method: 'GET',
                        url: '/1/indexes/' + encodeURIComponent(this.indexName),
                        body: {params: params}
                    },
                    callback: callback
                });
            },

            as: null,
            indexName: null,
            typeAheadArgs: null,
            typeAheadValueOption: null
        };

// extracted from https://github.com/component/map/blob/master/index.js
// without the crazy toFunction thing
        function map(arr, fn){
            var ret = [];
            for (var i = 0; i < arr.length; ++i) {
                ret.push(fn(arr[i], i));
            }
            return ret;
        }

        function prepareHost(protocol) {
            return function prepare(host) {
                return protocol + '//' + host.toLowerCase();
            };
        }

        function notImplemented() {
            var message = 'algoliasearch: Not implemented in this environment.\n' +
                'If you feel this is a mistake, write to support@algolia.com';

            throw new Error(message);
        }

        function deprecatedMessage(previousUsage, newUsage) {
            var githubAnchorLink = previousUsage.toLowerCase()
                .replace('.', '')
                .replace('()', '');

            return 'algoliasearch: `' + previousUsage + '` was replaced by `' +
                newUsage + '`. Please see https://github.com/algolia/algoliasearch-client-js/wiki/Deprecated#' + githubAnchorLink
        }

    }).call(this,require(1))
},{"1":1,"11":11,"13":13,"5":5,"9":9}],15:[function(require,module,exports){
    module.exports = JSONPRequest;

    var JSONPCounter = 0;

    function JSONPRequest(url, opts, cb) {
        if (opts.method !== 'GET') {
            cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));
            return;
        }

        var JSONPDebug = require(5)('algoliasearch:JSONP-request:' + url);

        JSONPDebug('start');

        var cbCalled = false;
        var timedOut = false;

        JSONPCounter += 1;
        var head = document.getElementsByTagName('head')[0];
        var script = document.createElement('script');
        var cbName = 'algoliaJSONP_' + JSONPCounter;
        var done = false;

        window[cbName] = function(data) {
            try {
                delete window[cbName];
            } catch (e) {
                window[cbName] = undefined;
            }

            if (timedOut) {
                return;
            }

            cbCalled = true;

            clean();

            cb(null, {
                body: data/*,
                 // We do not send the statusCode, there's no statusCode in JSONP, it will be
                 // computed using data.status && data.message like with XDR
                 statusCode*/
            });
        };

        // add callback by hand
        url += '&callback=' + cbName;

        // add body params by hand
        if (opts.body && opts.body.params) {
            url += '&' + opts.body.params;
        }

        var ontimeout = setTimeout(timeout, opts.timeout);

        // script onreadystatechange needed only for
        // <= IE8
        // https://github.com/angular/angular.js/issues/4523
        script.onreadystatechange = readystatechange;
        script.onload = success;
        script.onerror = error;

        script.async = true;
        script.defer = true;
        script.src = url;
        head.appendChild(script);

        function success() {
            JSONPDebug('success');

            if (done || timedOut) {
                return;
            }

            done = true;

            // script loaded but did not call the fn => script loading error
            if (!cbCalled) {
                JSONPDebug('fail: script loaded but did not call the callback');
                clean();
                cb(new Error('Failed to load JSONP script'));
            }
        }

        function readystatechange() {
            if (this.readyState === 'loaded' || this.readyState === 'complete') {
                success();
            }
        }

        function clean() {
            clearTimeout(ontimeout);
            script.onload = null;
            script.onreadystatechange = null;
            script.onerror = null;
            head.removeChild(script);

            try {
                delete window[cbName];
                delete window[cbName + '_loaded'];
            } catch (e) {
                window[cbName] = null;
                window[cbName + '_loaded'] = null;
            }
        }

        function timeout() {
            JSONPDebug('timeout');

            timedOut = true;
            clean();
            cb(new Error('Timeout - Could not connect to endpoint ' + url));
        }

        function error() {
            JSONPDebug('error');

            if (done || timedOut) {
                return;
            }

            clean();
            cb(new Error('Failed to load JSONP script'));
        }
    }

},{"5":5}],16:[function(require,module,exports){
    (function (global){
// This is the standalone browser build entry point
// Browser implementation of the Algolia Search JavaScript client,
// using XMLHttpRequest, XDomainRequest and JSONP as fallback
        module.exports = algoliasearch;

        var inherits = require(12);
        var Promise = global.Promise || require(8).Promise;

        var AlgoliaSearch = require(14);
        var inlineHeaders = require(18);
        var JSONPRequest = require(15);

        function algoliasearch(applicationID, apiKey, opts) {
            var extend = require(9);

            var getDocumentProtocol = require(17);

            opts = extend(true, {}, opts) || {};

            if (opts.protocol === undefined) {
                opts.protocol = getDocumentProtocol();
            }

            opts._ua = algoliasearch.ua;

            return new AlgoliaSearchBrowser(applicationID, apiKey, opts);
        }

        algoliasearch.version = require(19);
        algoliasearch.ua = 'Algolia for vanilla JavaScript ' + algoliasearch.version;

        var support = {
            hasXMLHttpRequest: 'XMLHttpRequest' in window,
            hasXDomainRequest: 'XDomainRequest' in window,
            cors: 'withCredentials' in new XMLHttpRequest(),
            timeout: 'timeout' in new XMLHttpRequest()
        };

        function AlgoliaSearchBrowser() {
            // call AlgoliaSearch constructor
            AlgoliaSearch.apply(this, arguments);
        }

        inherits(AlgoliaSearchBrowser, AlgoliaSearch);

        AlgoliaSearchBrowser.prototype._request = function(url, opts) {
            return new Promise(function(resolve, reject) {
                // no cors or XDomainRequest, no request
                if (!support.cors && !support.hasXDomainRequest) {
                    // very old browser, not supported
                    reject(new Error('CORS not supported'));
                    return;
                }

                url = inlineHeaders(url, opts.headers);

                var body = null;
                var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();
                var ontimeout;
                var timedOut;

                if (opts.body !== undefined) {
                    body = JSON.stringify(opts.body);
                }

                // do not rely on default XHR async flag, as some analytics code like hotjar
                // breaks it and set it to false by default
                if (req instanceof XMLHttpRequest) {
                    req.open(opts.method, url, true);
                } else {
                    req.open(opts.method, url);
                }

                if (support.cors && body !== null && opts.method !== 'GET') {
                    req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
                }

                // we set an empty onprogress listener
                // so that XDomainRequest on IE9 is not aborted
                // refs:
                //  - https://github.com/algolia/algoliasearch-client-js/issues/76
                //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
                req.onprogress = function noop() {};

                req.onload = load;
                req.onerror = error;

                if (support.timeout) {
                    // .timeout supported by both XHR and XDR,
                    // we do receive timeout event, tested
                    req.timeout = opts.timeout;

                    req.ontimeout = timeout;
                } else {
                    ontimeout = setTimeout(timeout, opts.timeout);
                }

                req.send(body);

                // event object not received in IE8, at least
                // but we do not use it, still important to note
                function load(/*event*/) {
                    // When browser does not supports req.timeout, we can
                    // have both a load and timeout event, since handled by a dumb setTimeout
                    if (timedOut) {
                        return;
                    }

                    if (!support.timeout) {
                        clearTimeout(ontimeout);
                    }

                    var response = null;

                    try {
                        response = JSON.parse(req.responseText);
                    } catch(e) {}

                    resolve({
                        body: response,
                        statusCode: req.status
                    });
                }

                function error(event) {
                    if (timedOut) {
                        return;
                    }

                    if (!support.timeout) {
                        clearTimeout(ontimeout);
                    }

                    // error event is trigerred both with XDR/XHR on:
                    //   - DNS error
                    //   - unallowed cross domain request
                    reject(new Error('Could not connect to host, error was:' + event));
                }

                function timeout() {
                    if (!support.timeout) {
                        timedOut = true;
                        req.abort();
                    }

                    resolve(new Error('Timeout - Could not connect to endpoint ' + url));
                }

            });
        };

        AlgoliaSearchBrowser.prototype._request.fallback = function(url, opts) {
            url = inlineHeaders(url, opts.headers);

            return new Promise(function(resolve, reject) {
                JSONPRequest(url, opts, function JSONPRequestDone(err, content) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    resolve(content);
                });
            });
        };

        AlgoliaSearchBrowser.prototype._promise = {
            reject: function(val) {
                return Promise.reject(val);
            },
            resolve: function(val) {
                return Promise.resolve(val);
            },
            delay: function(ms) {
                return new Promise(function(resolve/*, reject*/) {
                    setTimeout(resolve, ms);
                });
            }
        };

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"12":12,"14":14,"15":15,"17":17,"18":18,"19":19,"8":8,"9":9}],17:[function(require,module,exports){
    (function (global){
        module.exports = getDocumentProtocol;

        function getDocumentProtocol() {
            var protocol = global.document.location.protocol;

            // when in `file:` mode (local html file), default to `http:`
            if (protocol !== 'http:' && protocol !== 'https:') {
                protocol = 'http:';
            }

            return protocol;
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],18:[function(require,module,exports){
    module.exports = inlineHeaders;

    var querystring = require(4);

    function inlineHeaders(url, headers) {
        if (/\?/.test(url)) {
            url += '&';
        } else {
            url += '?';
        }

        return url + querystring.encode(headers);
    }

},{"4":4}],19:[function(require,module,exports){
    module.exports="3.1.0"
},{}]},{},[16])(16)
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.algoliasearchHelper = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    /**
     */
    "use strict";
    var AlgoliaSearchHelper = require( "./src/algoliasearch.helper" );
    /**
     * The algoliasearch-helper module is a function that instanciate the helper.
     * @module algoliasearch-helper
     * @param  {AlgoliaSearch} client an AlgoliaSearch client
     * @param  {string} index the index name to query
     * @param  {SearchParameters | object} options an object defining the initial config of the search. It doesn't have to be a {SearchParamaters}, just an object containing the properties you need from it.
     * @return {AlgoliaSearchHelper}
     */
    function helper( client, index, opts ) {
        return new AlgoliaSearchHelper( client, index, opts );
    }

    /**
     * The version currently used
     * @member module:algoliasearch-helper.version
     */
    helper.version = "2.0.0-rc4";

    module.exports = helper;

},{"./src/algoliasearch.helper":75}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };

    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;

        if (!this._events)
            this._events = {};

        // If there is no 'error' event listener then throw.
        if (type === 'error') {
            if (!this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
            }
        }

        handler = this._events[type];

        if (isUndefined(handler))
            return false;

        if (isFunction(handler)) {
            switch (arguments.length) {
                // fast cases
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                // slower
                default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];

            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }

        return true;
    };

    EventEmitter.prototype.addListener = function(type, listener) {
        var m;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events)
            this._events = {};

        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (this._events.newListener)
            this.emit('newListener', type,
                isFunction(listener.listener) ?
                    listener.listener : listener);

        if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
        else if (isObject(this._events[type]))
        // If we've already got an array, just append.
            this._events[type].push(listener);
        else
        // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];

        // Check for listener leak
        if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                if (typeof console.trace === 'function') {
                    // not supported in IE 10
                    console.trace();
                }
            }
        }

        return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        var fired = false;

        function g() {
            this.removeListener(type, g);

            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }

        g.listener = listener;
        this.on(type, g);

        return this;
    };

// emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events || !this._events[type])
            return this;

        list = this._events[type];
        length = list.length;
        position = -1;

        if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);

        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener ||
                    (list[i].listener && list[i].listener === listener)) {
                    position = i;
                    break;
                }
            }

            if (position < 0)
                return this;

            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }

            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }

        return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;

        if (!this._events)
            return this;

        // not listening for removeListener, no need to emit
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }

        listeners = this._events[type];

        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else {
            // LIFO order
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];

        return this;
    };

    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])
            ret = 0;
        else if (isFunction(emitter._events[type]))
            ret = 1;
        else
            ret = emitter._events[type].length;
        return ret;
    };

    function isFunction(arg) {
        return typeof arg === 'function';
    }

    function isNumber(arg) {
        return typeof arg === 'number';
    }

    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }

    function isUndefined(arg) {
        return arg === void 0;
    }

},{}],3:[function(require,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],4:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;

    function drainQueue() {
        if (draining) {
            return;
        }
        draining = true;
        var currentQueue;
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            var i = -1;
            while (++i < len) {
                currentQueue[i]();
            }
            len = queue.length;
        }
        draining = false;
    }
    process.nextTick = function (fun) {
        queue.push(fun);
        if (!draining) {
            setTimeout(drainQueue, 0);
        }
    };

    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

// TODO(shtylman)
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
    module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object'
            && typeof arg.copy === 'function'
            && typeof arg.fill === 'function'
            && typeof arg.readUInt8 === 'function';
    }
},{}],6:[function(require,module,exports){
    (function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                    case '%s': return String(args[i++]);
                    case '%d': return Number(args[i++]);
                    case '%j':
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return '[Circular]';
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += ' ' + x;
                } else {
                    str += ' ' + inspect(x);
                }
            }
            return str;
        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error('%s %d: %s', set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            'bold' : [1, 22],
            'italic' : [3, 23],
            'underline' : [4, 24],
            'inverse' : [7, 27],
            'white' : [37, 39],
            'grey' : [90, 39],
            'black' : [30, 39],
            'blue' : [34, 39],
            'cyan' : [36, 39],
            'green' : [32, 39],
            'magenta' : [35, 39],
            'red' : [31, 39],
            'yellow' : [33, 39]
        };

// Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                    '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                    // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                    // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value)
                && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ': ' + value.name : '';
                    return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = '', array = false, braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                    return ctx.stylize('[Object]', 'special');
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                        .replace(/'/g, "\\'")
                        .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
                return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
                return ctx.stylize('null', 'null');
        }


        function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push('');
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                    str = ctx.stylize('[Getter]', 'special');
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize('[Setter]', 'special');
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                        if (array) {
                            str = str.split('\n').map(function(line) {
                                return '  ' + line;
                            }).join('\n').substr(2);
                        } else {
                            str = '\n' + str.split('\n').map(function(line) {
                                return '   ' + line;
                            }).join('\n');
                        }
                    }
                } else {
                    str = ctx.stylize('[Circular]', 'special');
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                } else {
                    name = name.replace(/'/g, "\\'")
                        .replace(/\\"/g, '"')
                        .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                }
            }

            return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
                return braces[0] +
                    (base === '' ? '' : base + '\n ') +
                    ' ' +
                    output.join(',\n  ') +
                    ' ' +
                    braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
            'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


// log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

    }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":5,"_process":4,"inherits":3}],7:[function(require,module,exports){
    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
        var index = -1,
            length = array ? array.length : 0,
            resIndex = -1,
            result = [];

        while (++index < length) {
            var value = array[index];
            if (value) {
                result[++resIndex] = value;
            }
        }
        return result;
    }

    module.exports = compact;

},{}],8:[function(require,module,exports){
    var baseCallback = require('../internal/baseCallback');

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
 *   return chr.user == 'barney';
 * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, thisArg) {
        var index = -1,
            length = array ? array.length : 0;

        predicate = baseCallback(predicate, thisArg, 3);
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }

    module.exports = findIndex;

},{"../internal/baseCallback":17}],9:[function(require,module,exports){
    var baseCallback = require('../internal/baseCallback'),
        baseEach = require('../internal/baseEach'),
        baseFind = require('../internal/baseFind'),
        findIndex = require('../array/findIndex'),
        isArray = require('../lang/isArray');

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
 *   return chr.age < 40;
 * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    function find(collection, predicate, thisArg) {
        if (isArray(collection)) {
            var index = findIndex(collection, predicate, thisArg);
            return index > -1 ? collection[index] : undefined;
        }
        predicate = baseCallback(predicate, thisArg, 3);
        return baseFind(collection, predicate, baseEach);
    }

    module.exports = find;

},{"../array/findIndex":8,"../internal/baseCallback":17,"../internal/baseEach":19,"../internal/baseFind":20,"../lang/isArray":59}],10:[function(require,module,exports){
    var arrayEach = require('../internal/arrayEach'),
        baseEach = require('../internal/baseEach'),
        bindCallback = require('../internal/bindCallback'),
        isArray = require('../lang/isArray');

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    function forEach(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
            ? arrayEach(collection, iteratee)
            : baseEach(collection, bindCallback(iteratee, thisArg, 3));
    }

    module.exports = forEach;

},{"../internal/arrayEach":15,"../internal/baseEach":19,"../internal/bindCallback":34,"../lang/isArray":59}],11:[function(require,module,exports){
    var arrayReduce = require('../internal/arrayReduce'),
        baseCallback = require('../internal/baseCallback'),
        baseEach = require('../internal/baseEach'),
        baseReduce = require('../internal/baseReduce'),
        isArray = require('../lang/isArray');

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `merge`, and `sortAllBy`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
 *   result[key] = n * 3;
 *   return result;
 * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator, thisArg) {
        var func = isArray(collection) ? arrayReduce : baseReduce;
        return func(collection, baseCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
    }

    module.exports = reduce;

},{"../internal/arrayReduce":16,"../internal/baseCallback":17,"../internal/baseEach":19,"../internal/baseReduce":30,"../lang/isArray":59}],12:[function(require,module,exports){
    var isNative = require('../lang/isNative');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeNow = isNative(nativeNow = Date.now) && nativeNow;

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
            return new Date().getTime();
        };

    module.exports = now;

},{"../lang/isNative":62}],13:[function(require,module,exports){
    var baseSlice = require('../internal/baseSlice'),
        createWrapper = require('../internal/createWrapper'),
        replaceHolders = require('../internal/replaceHolders');

    /** Used to compose bitmasks for wrapper metadata. */
    var BIND_FLAG = 1,
        PARTIAL_FLAG = 32;

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    function bind(func, thisArg) {
        var bitmask = BIND_FLAG;
        if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bind.placeholder);

            bitmask |= PARTIAL_FLAG;
        }
        return createWrapper(func, bitmask, thisArg, partials, holders);
    }

// Assign default placeholders.
    bind.placeholder = {};

    module.exports = bind;

},{"../internal/baseSlice":32,"../internal/createWrapper":41,"../internal/replaceHolders":54}],14:[function(require,module,exports){
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
        var index = -1,
            length = source.length;

        array || (array = Array(length));
        while (++index < length) {
            array[index] = source[index];
        }
        return array;
    }

    module.exports = arrayCopy;

},{}],15:[function(require,module,exports){
    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
        var index = -1,
            length = array.length;

        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }

    module.exports = arrayEach;

},{}],16:[function(require,module,exports){
    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
        var index = -1,
            length = array.length;

        if (initFromArray && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }

    module.exports = arrayReduce;

},{}],17:[function(require,module,exports){
    var baseMatches = require('./baseMatches'),
        baseMatchesProperty = require('./baseMatchesProperty'),
        baseProperty = require('./baseProperty'),
        bindCallback = require('./bindCallback'),
        identity = require('../utility/identity'),
        isBindable = require('./isBindable');

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
        var type = typeof func;
        if (type == 'function') {
            return (typeof thisArg != 'undefined' && isBindable(func))
                ? bindCallback(func, thisArg, argCount)
                : func;
        }
        if (func == null) {
            return identity;
        }
        if (type == 'object') {
            return baseMatches(func);
        }
        return typeof thisArg == 'undefined'
            ? baseProperty(func + '')
            : baseMatchesProperty(func + '', thisArg);
    }

    module.exports = baseCallback;

},{"../utility/identity":71,"./baseMatches":27,"./baseMatchesProperty":28,"./baseProperty":29,"./bindCallback":34,"./isBindable":46}],18:[function(require,module,exports){
    (function (global){
        var isObject = require('../lang/isObject');

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
            function Object() {}
            return function(prototype) {
                if (isObject(prototype)) {
                    Object.prototype = prototype;
                    var result = new Object;
                    Object.prototype = null;
                }
                return result || global.Object();
            };
        }());

        module.exports = baseCreate;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isObject":63}],19:[function(require,module,exports){
    var baseForOwn = require('./baseForOwn'),
        isLength = require('./isLength'),
        toObject = require('./toObject');

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEach(collection, iteratee) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
            return baseForOwn(collection, iteratee);
        }
        var index = -1,
            iterable = toObject(collection);

        while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    }

    module.exports = baseEach;

},{"./baseForOwn":22,"./isLength":48,"./toObject":57}],20:[function(require,module,exports){
    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
            }
        });
        return result;
    }

    module.exports = baseFind;

},{}],21:[function(require,module,exports){
    var toObject = require('./toObject');

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseFor(object, iteratee, keysFunc) {
        var index = -1,
            iterable = toObject(object),
            props = keysFunc(object),
            length = props.length;

        while (++index < length) {
            var key = props[index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    }

    module.exports = baseFor;

},{"./toObject":57}],22:[function(require,module,exports){
    var baseFor = require('./baseFor'),
        keys = require('../object/keys');

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
        return baseFor(object, iteratee, keys);
    }

    module.exports = baseForOwn;

},{"../object/keys":67,"./baseFor":21}],23:[function(require,module,exports){
    var baseIsEqualDeep = require('./baseIsEqualDeep');

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
        // Exit early for identical values.
        if (value === other) {
            // Treat `+0` vs. `-0` as not equal.
            return value !== 0 || (1 / value == 1 / other);
        }
        var valType = typeof value,
            othType = typeof other;

        // Exit early for unlike primitive values.
        if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
            value == null || other == null) {
            // Return `false` unless both values are `NaN`.
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
    }

    module.exports = baseIsEqual;

},{"./baseIsEqualDeep":24}],24:[function(require,module,exports){
    var equalArrays = require('./equalArrays'),
        equalByTag = require('./equalByTag'),
        equalObjects = require('./equalObjects'),
        isArray = require('../lang/isArray'),
        isTypedArray = require('../lang/isTypedArray');

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = arrayTag,
            othTag = arrayTag;

        if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
                objTag = objectTag;
            } else if (objTag != objectTag) {
                objIsArr = isTypedArray(object);
            }
        }
        if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
                othTag = objectTag;
            } else if (othTag != objectTag) {
                othIsArr = isTypedArray(other);
            }
        }
        var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

        if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
        }
        var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (valWrapped || othWrapped) {
            return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
        }
        if (!isSameTag) {
            return false;
        }
        // Assume cyclic values are equal.
        // For more information on detecting circular references see https://es5.github.io/#JO.
        stackA || (stackA = []);
        stackB || (stackB = []);

        var length = stackA.length;
        while (length--) {
            if (stackA[length] == object) {
                return stackB[length] == other;
            }
        }
        // Add `object` and `other` to the stack of traversed objects.
        stackA.push(object);
        stackB.push(other);

        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

        stackA.pop();
        stackB.pop();

        return result;
    }

    module.exports = baseIsEqualDeep;

},{"../lang/isArray":59,"../lang/isTypedArray":65,"./equalArrays":42,"./equalByTag":43,"./equalObjects":44}],25:[function(require,module,exports){
    /**
     * The base implementation of `_.isFunction` without support for environments
     * with incorrect `typeof` results.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     */
    function baseIsFunction(value) {
        // Avoid a Chakra JIT bug in compatibility modes of IE 11.
        // See https://github.com/jashkenas/underscore/issues/1621 for more details.
        return typeof value == 'function' || false;
    }

    module.exports = baseIsFunction;

},{}],26:[function(require,module,exports){
    var baseIsEqual = require('./baseIsEqual');

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
        var length = props.length;
        if (object == null) {
            return !length;
        }
        var index = -1,
            noCustomizer = !customizer;

        while (++index < length) {
            if ((noCustomizer && strictCompareFlags[index])
                    ? values[index] !== object[props[index]]
                    : !hasOwnProperty.call(object, props[index])
            ) {
                return false;
            }
        }
        index = -1;
        while (++index < length) {
            var key = props[index];
            if (noCustomizer && strictCompareFlags[index]) {
                var result = hasOwnProperty.call(object, key);
            } else {
                var objValue = object[key],
                    srcValue = values[index];

                result = customizer ? customizer(objValue, srcValue, key) : undefined;
                if (typeof result == 'undefined') {
                    result = baseIsEqual(srcValue, objValue, customizer, true);
                }
            }
            if (!result) {
                return false;
            }
        }
        return true;
    }

    module.exports = baseIsMatch;

},{"./baseIsEqual":23}],27:[function(require,module,exports){
    var baseIsMatch = require('./baseIsMatch'),
        isStrictComparable = require('./isStrictComparable'),
        keys = require('../object/keys');

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
        var props = keys(source),
            length = props.length;

        if (length == 1) {
            var key = props[0],
                value = source[key];

            if (isStrictComparable(value)) {
                return function(object) {
                    return object != null && object[key] === value && hasOwnProperty.call(object, key);
                };
            }
        }
        var values = Array(length),
            strictCompareFlags = Array(length);

        while (length--) {
            value = source[props[length]];
            values[length] = value;
            strictCompareFlags[length] = isStrictComparable(value);
        }
        return function(object) {
            return baseIsMatch(object, props, values, strictCompareFlags);
        };
    }

    module.exports = baseMatches;

},{"../object/keys":67,"./baseIsMatch":26,"./isStrictComparable":50}],28:[function(require,module,exports){
    var baseIsEqual = require('./baseIsEqual'),
        isStrictComparable = require('./isStrictComparable');

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
        if (isStrictComparable(value)) {
            return function(object) {
                return object != null && object[key] === value;
            };
        }
        return function(object) {
            return object != null && baseIsEqual(value, object[key], null, true);
        };
    }

    module.exports = baseMatchesProperty;

},{"./baseIsEqual":23,"./isStrictComparable":50}],29:[function(require,module,exports){
    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
        return function(object) {
            return object == null ? undefined : object[key];
        };
    }

    module.exports = baseProperty;

},{}],30:[function(require,module,exports){
    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands or `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection
                ? (initFromCollection = false, value)
                : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
    }

    module.exports = baseReduce;

},{}],31:[function(require,module,exports){
    var identity = require('../utility/identity'),
        metaMap = require('./metaMap');

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
    };

    module.exports = baseSetData;

},{"../utility/identity":71,"./metaMap":52}],32:[function(require,module,exports){
    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
        var index = -1,
            length = array.length;

        start = start == null ? 0 : (+start || 0);
        if (start < 0) {
            start = -start > length ? 0 : (length + start);
        }
        end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
        if (end < 0) {
            end += length;
        }
        length = start > end ? 0 : ((end - start) >>> 0);
        start >>>= 0;

        var result = Array(length);
        while (++index < length) {
            result[index] = array[index + start];
        }
        return result;
    }

    module.exports = baseSlice;

},{}],33:[function(require,module,exports){
    /**
     * Converts `value` to a string if it is not one. An empty string is returned
     * for `null` or `undefined` values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
        if (typeof value == 'string') {
            return value;
        }
        return value == null ? '' : (value + '');
    }

    module.exports = baseToString;

},{}],34:[function(require,module,exports){
    var identity = require('../utility/identity');

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
        if (typeof func != 'function') {
            return identity;
        }
        if (typeof thisArg == 'undefined') {
            return func;
        }
        switch (argCount) {
            case 1: return function(value) {
                return func.call(thisArg, value);
            };
            case 3: return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
            };
            case 5: return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
            };
        }
        return function() {
            return func.apply(thisArg, arguments);
        };
    }

    module.exports = bindCallback;

},{"../utility/identity":71}],35:[function(require,module,exports){
    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
        var holdersLength = holders.length,
            argsIndex = -1,
            argsLength = nativeMax(args.length - holdersLength, 0),
            leftIndex = -1,
            leftLength = partials.length,
            result = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
        }
        while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
        }
        return result;
    }

    module.exports = composeArgs;

},{}],36:[function(require,module,exports){
    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
        var holdersIndex = -1,
            holdersLength = holders.length,
            argsIndex = -1,
            argsLength = nativeMax(args.length - holdersLength, 0),
            rightIndex = -1,
            rightLength = partials.length,
            result = Array(argsLength + rightLength);

        while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
        }
        var pad = argsIndex;
        while (++rightIndex < rightLength) {
            result[pad + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
            result[pad + holders[holdersIndex]] = args[argsIndex++];
        }
        return result;
    }

    module.exports = composeArgsRight;

},{}],37:[function(require,module,exports){
    (function (global){
        var createCtorWrapper = require('./createCtorWrapper');

        /**
         * Creates a function that wraps `func` and invokes it with the `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new bound function.
         */
        function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);

            function wrapper() {
                var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                return fn.apply(thisArg, arguments);
            }
            return wrapper;
        }

        module.exports = createBindWrapper;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./createCtorWrapper":38}],38:[function(require,module,exports){
    var baseCreate = require('./baseCreate'),
        isObject = require('../lang/isObject');

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
        return function() {
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, arguments);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
        };
    }

    module.exports = createCtorWrapper;

},{"../lang/isObject":63,"./baseCreate":18}],39:[function(require,module,exports){
    (function (global){
        var arrayCopy = require('./arrayCopy'),
            composeArgs = require('./composeArgs'),
            composeArgsRight = require('./composeArgsRight'),
            createCtorWrapper = require('./createCtorWrapper'),
            reorder = require('./reorder'),
            replaceHolders = require('./replaceHolders');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            BIND_KEY_FLAG = 2,
            CURRY_BOUND_FLAG = 4,
            CURRY_FLAG = 8,
            CURRY_RIGHT_FLAG = 16,
            PARTIAL_FLAG = 32,
            PARTIAL_RIGHT_FLAG = 64,
            ARY_FLAG = 256;

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a function that wraps `func` and invokes it with optional `this`
         * binding of, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG,
                isBind = bitmask & BIND_FLAG,
                isBindKey = bitmask & BIND_KEY_FLAG,
                isCurry = bitmask & CURRY_FLAG,
                isCurryBound = bitmask & CURRY_BOUND_FLAG,
                isCurryRight = bitmask & CURRY_RIGHT_FLAG;

            var Ctor = !isBindKey && createCtorWrapper(func),
                key = func;

            function wrapper() {
                // Avoid `arguments` object use disqualifying optimizations by
                // converting it to an array before providing it to other functions.
                var length = arguments.length,
                    index = length,
                    args = Array(length);

                while (index--) {
                    args[index] = arguments[index];
                }
                if (partials) {
                    args = composeArgs(args, partials, holders);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight);
                }
                if (isCurry || isCurryRight) {
                    var placeholder = wrapper.placeholder,
                        argsHolders = replaceHolders(args, placeholder);

                    length -= argsHolders.length;
                    if (length < arity) {
                        var newArgPos = argPos ? arrayCopy(argPos) : null,
                            newArity = nativeMax(arity - length, 0),
                            newsHolders = isCurry ? argsHolders : null,
                            newHoldersRight = isCurry ? null : argsHolders,
                            newPartials = isCurry ? args : null,
                            newPartialsRight = isCurry ? null : args;

                        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                        if (!isCurryBound) {
                            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                        }
                        var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
                        result.placeholder = placeholder;
                        return result;
                    }
                }
                var thisBinding = isBind ? thisArg : this;
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (argPos) {
                    args = reorder(args, argPos);
                }
                if (isAry && ary < args.length) {
                    args.length = ary;
                }
                var fn = (this && this !== global && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }

        module.exports = createHybridWrapper;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./arrayCopy":14,"./composeArgs":35,"./composeArgsRight":36,"./createCtorWrapper":38,"./reorder":53,"./replaceHolders":54}],40:[function(require,module,exports){
    (function (global){
        var createCtorWrapper = require('./createCtorWrapper');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1;

        /**
         * Creates a function that wraps `func` and invokes it with the optional `this`
         * binding of `thisArg` and the `partials` prepended to those provided to
         * the wrapper.
         *
         * @private
         * @param {Function} func The function to partially apply arguments to.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to the new function.
         * @returns {Function} Returns the new bound function.
         */
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG,
                Ctor = createCtorWrapper(func);

            function wrapper() {
                // Avoid `arguments` object use disqualifying optimizations by
                // converting it to an array before providing it `func`.
                var argsIndex = -1,
                    argsLength = arguments.length,
                    leftIndex = -1,
                    leftLength = partials.length,
                    args = Array(argsLength + leftLength);

                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
        }

        module.exports = createPartialWrapper;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./createCtorWrapper":38}],41:[function(require,module,exports){
    var baseSetData = require('./baseSetData'),
        createBindWrapper = require('./createBindWrapper'),
        createHybridWrapper = require('./createHybridWrapper'),
        createPartialWrapper = require('./createPartialWrapper'),
        getData = require('./getData'),
        mergeData = require('./mergeData'),
        setData = require('./setData');

    /** Used to compose bitmasks for wrapper metadata. */
    var BIND_FLAG = 1,
        BIND_KEY_FLAG = 2,
        PARTIAL_FLAG = 32,
        PARTIAL_RIGHT_FLAG = 64;

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & BIND_KEY_FLAG;
        if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
        }
        length -= (holders ? holders.length : 0);
        if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = null;
        }
        var data = !isBindKey && getData(func),
            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

        if (data && data !== true) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
        }
        newData[9] = arity == null
            ? (isBindKey ? 0 : func.length)
            : (nativeMax(arity - length, 0) || 0);

        if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
        } else {
            result = createHybridWrapper.apply(undefined, newData);
        }
        var setter = data ? baseSetData : setData;
        return setter(result, newData);
    }

    module.exports = createWrapper;

},{"./baseSetData":31,"./createBindWrapper":37,"./createHybridWrapper":39,"./createPartialWrapper":40,"./getData":45,"./mergeData":51,"./setData":55}],42:[function(require,module,exports){
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var index = -1,
            arrLength = array.length,
            othLength = other.length,
            result = true;

        if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
            return false;
        }
        // Deep compare the contents, ignoring non-numeric properties.
        while (result && ++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            result = undefined;
            if (customizer) {
                result = isWhere
                    ? customizer(othValue, arrValue, index)
                    : customizer(arrValue, othValue, index);
            }
            if (typeof result == 'undefined') {
                // Recursively compare arrays (susceptible to call stack limits).
                if (isWhere) {
                    var othIndex = othLength;
                    while (othIndex--) {
                        othValue = other[othIndex];
                        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                        if (result) {
                            break;
                        }
                    }
                } else {
                    result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                }
            }
        }
        return !!result;
    }

    module.exports = equalArrays;

},{}],43:[function(require,module,exports){
    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        stringTag = '[object String]';

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
        switch (tag) {
            case boolTag:
            case dateTag:
                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                return +object == +other;

            case errorTag:
                return object.name == other.name && object.message == other.message;

            case numberTag:
                // Treat `NaN` vs. `NaN` as equal.
                return (object != +object)
                    ? other != +other
                    // But, treat `-0` vs. `+0` as not equal.
                    : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

            case regexpTag:
            case stringTag:
                // Coerce regexes to strings and treat strings primitives and string
                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                return object == (other + '');
        }
        return false;
    }

    module.exports = equalByTag;

},{}],44:[function(require,module,exports){
    var keys = require('../object/keys');

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
        var objProps = keys(object),
            objLength = objProps.length,
            othProps = keys(other),
            othLength = othProps.length;

        if (objLength != othLength && !isWhere) {
            return false;
        }
        var hasCtor,
            index = -1;

        while (++index < objLength) {
            var key = objProps[index],
                result = hasOwnProperty.call(other, key);

            if (result) {
                var objValue = object[key],
                    othValue = other[key];

                result = undefined;
                if (customizer) {
                    result = isWhere
                        ? customizer(othValue, objValue, key)
                        : customizer(objValue, othValue, key);
                }
                if (typeof result == 'undefined') {
                    // Recursively compare objects (susceptible to call stack limits).
                    result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
                }
            }
            if (!result) {
                return false;
            }
            hasCtor || (hasCtor = key == 'constructor');
        }
        if (!hasCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                return false;
            }
        }
        return true;
    }

    module.exports = equalObjects;

},{"../object/keys":67}],45:[function(require,module,exports){
    var metaMap = require('./metaMap'),
        noop = require('../utility/noop');

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
    };

    module.exports = getData;

},{"../utility/noop":72,"./metaMap":52}],46:[function(require,module,exports){
    var baseSetData = require('./baseSetData'),
        isNative = require('../lang/isNative'),
        support = require('../support');

    /** Used to detect named functions. */
    var reFuncName = /^\s*function[ \n\r\t]+\w/;

    /** Used to detect functions containing a `this` reference. */
    var reThis = /\bthis\b/;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /**
     * Checks if `func` is eligible for `this` binding.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
     */
    function isBindable(func) {
        var result = !(support.funcNames ? func.name : support.funcDecomp);

        if (!result) {
            var source = fnToString.call(func);
            if (!support.funcNames) {
                result = !reFuncName.test(source);
            }
            if (!result) {
                // Check if `func` references the `this` keyword and store the result.
                result = reThis.test(source) || isNative(func);
                baseSetData(func, result);
            }
        }
        return result;
    }

    module.exports = isBindable;

},{"../lang/isNative":62,"../support":70,"./baseSetData":31}],47:[function(require,module,exports){
    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        value = +value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
    }

    module.exports = isIndex;

},{}],48:[function(require,module,exports){
    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on ES `ToLength`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    module.exports = isLength;

},{}],49:[function(require,module,exports){
    /**
     * Checks if `value` is object-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     */
    function isObjectLike(value) {
        return (value && typeof value == 'object') || false;
    }

    module.exports = isObjectLike;

},{}],50:[function(require,module,exports){
    var isObject = require('../lang/isObject');

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
        return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    module.exports = isStrictComparable;

},{"../lang/isObject":63}],51:[function(require,module,exports){
    var arrayCopy = require('./arrayCopy'),
        composeArgs = require('./composeArgs'),
        composeArgsRight = require('./composeArgsRight'),
        replaceHolders = require('./replaceHolders');

    /** Used to compose bitmasks for wrapper metadata. */
    var BIND_FLAG = 1,
        BIND_KEY_FLAG = 2,
        CURRY_BOUND_FLAG = 4,
        CURRY_RIGHT_FLAG = 16,
        REARG_FLAG = 128,
        ARY_FLAG = 256;

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
        var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask;

        var arityFlags = ARY_FLAG | REARG_FLAG,
            bindFlags = BIND_FLAG | BIND_KEY_FLAG,
            comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

        var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
            isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
            argPos = (isRearg ? data : source)[7],
            ary = (isAry ? data : source)[8];

        var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
            !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

        var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
            (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

        // Exit early if metadata can't be merged.
        if (!(isCommon || isCombo)) {
            return data;
        }
        // Use source `thisArg` if available.
        if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
        }
        // Compose partial arguments.
        var value = source[3];
        if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
        }
        // Compose partial right arguments.
        value = source[5];
        if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
        }
        // Use source `argPos` if available.
        value = source[7];
        if (value) {
            data[7] = arrayCopy(value);
        }
        // Use source `ary` if it's smaller.
        if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        // Use source `arity` if one is not provided.
        if (data[9] == null) {
            data[9] = source[9];
        }
        // Use source `func` and merge bitmasks.
        data[0] = source[0];
        data[1] = newBitmask;

        return data;
    }

    module.exports = mergeData;

},{"./arrayCopy":14,"./composeArgs":35,"./composeArgsRight":36,"./replaceHolders":54}],52:[function(require,module,exports){
    (function (global){
        var isNative = require('../lang/isNative');

        /** Native method references. */
        var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        module.exports = metaMap;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":62}],53:[function(require,module,exports){
    var arrayCopy = require('./arrayCopy'),
        isIndex = require('./isIndex');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
        var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = arrayCopy(array);

        while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
        }
        return array;
    }

    module.exports = reorder;

},{"./arrayCopy":14,"./isIndex":47}],54:[function(require,module,exports){
    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

        while (++index < length) {
            if (array[index] === placeholder) {
                array[index] = PLACEHOLDER;
                result[++resIndex] = index;
            }
        }
        return result;
    }

    module.exports = replaceHolders;

},{}],55:[function(require,module,exports){
    var baseSetData = require('./baseSetData'),
        now = require('../date/now');

    /** Used to detect when a function becomes hot. */
    var HOT_COUNT = 150,
        HOT_SPAN = 16;

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
        var count = 0,
            lastCalled = 0;

        return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                    return key;
                }
            } else {
                count = 0;
            }
            return baseSetData(key, value);
        };
    }());

    module.exports = setData;

},{"../date/now":12,"./baseSetData":31}],56:[function(require,module,exports){
    var isArguments = require('../lang/isArguments'),
        isArray = require('../lang/isArray'),
        isIndex = require('./isIndex'),
        isLength = require('./isLength'),
        keysIn = require('../object/keysIn'),
        support = require('../support');

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
        var props = keysIn(object),
            propsLength = props.length,
            length = propsLength && object.length;

        var allowIndexes = length && isLength(length) &&
            (isArray(object) || (support.nonEnumArgs && isArguments(object)));

        var index = -1,
            result = [];

        while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                result.push(key);
            }
        }
        return result;
    }

    module.exports = shimKeys;

},{"../lang/isArguments":58,"../lang/isArray":59,"../object/keysIn":68,"../support":70,"./isIndex":47,"./isLength":48}],57:[function(require,module,exports){
    var isObject = require('../lang/isObject');

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
        return isObject(value) ? value : Object(value);
    }

    module.exports = toObject;

},{"../lang/isObject":63}],58:[function(require,module,exports){
    var isLength = require('../internal/isLength'),
        isObjectLike = require('../internal/isObjectLike');

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
        var length = isObjectLike(value) ? value.length : undefined;
        return (isLength(length) && objToString.call(value) == argsTag) || false;
    }

    module.exports = isArguments;

},{"../internal/isLength":48,"../internal/isObjectLike":49}],59:[function(require,module,exports){
    var isLength = require('../internal/isLength'),
        isNative = require('./isNative'),
        isObjectLike = require('../internal/isObjectLike');

    /** `Object#toString` result references. */
    var arrayTag = '[object Array]';

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
            return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
        };

    module.exports = isArray;

},{"../internal/isLength":48,"../internal/isObjectLike":49,"./isNative":62}],60:[function(require,module,exports){
    var isArguments = require('./isArguments'),
        isArray = require('./isArray'),
        isFunction = require('./isFunction'),
        isLength = require('../internal/isLength'),
        isObjectLike = require('../internal/isObjectLike'),
        isString = require('./isString'),
        keys = require('../object/keys');

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
        if (value == null) {
            return true;
        }
        var length = value.length;
        if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
            (isObjectLike(value) && isFunction(value.splice)))) {
            return !length;
        }
        return !keys(value).length;
    }

    module.exports = isEmpty;

},{"../internal/isLength":48,"../internal/isObjectLike":49,"../object/keys":67,"./isArguments":58,"./isArray":59,"./isFunction":61,"./isString":64}],61:[function(require,module,exports){
    (function (global){
        var baseIsFunction = require('../internal/baseIsFunction'),
            isNative = require('./isNative');

        /** `Object#toString` result references. */
        var funcTag = '[object Function]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the `toStringTag` of values.
         * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
         * for more details.
         */
        var objToString = objectProto.toString;

        /** Native method references. */
        var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in older versions of Chrome and Safari which return 'function' for regexes
            // and Safari 8 equivalents which return 'object' for typed array constructors.
            return objToString.call(value) == funcTag;
        };

        module.exports = isFunction;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../internal/baseIsFunction":25,"./isNative":62}],62:[function(require,module,exports){
    var escapeRegExp = require('../string/escapeRegExp'),
        isObjectLike = require('../internal/isObjectLike');

    /** `Object#toString` result references. */
    var funcTag = '[object Function]';

    /** Used to detect host constructors (Safari > 5). */
    var reHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
        escapeRegExp(objToString)
            .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
        if (value == null) {
            return false;
        }
        if (objToString.call(value) == funcTag) {
            return reNative.test(fnToString.call(value));
        }
        return (isObjectLike(value) && reHostCtor.test(value)) || false;
    }

    module.exports = isNative;

},{"../internal/isObjectLike":49,"../string/escapeRegExp":69}],63:[function(require,module,exports){
    /**
     * Checks if `value` is the language type of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
        // Avoid a V8 JIT bug in Chrome 19-20.
        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
        var type = typeof value;
        return type == 'function' || (value && type == 'object') || false;
    }

    module.exports = isObject;

},{}],64:[function(require,module,exports){
    var isObjectLike = require('../internal/isObjectLike');

    /** `Object#toString` result references. */
    var stringTag = '[object String]';

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
    }

    module.exports = isString;

},{"../internal/isObjectLike":49}],65:[function(require,module,exports){
    var isLength = require('../internal/isLength'),
        isObjectLike = require('../internal/isObjectLike');

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
            typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                        typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                            typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
        return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
    }

    module.exports = isTypedArray;

},{"../internal/isLength":48,"../internal/isObjectLike":49}],66:[function(require,module,exports){
    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
        return typeof value == 'undefined';
    }

    module.exports = isUndefined;

},{}],67:[function(require,module,exports){
    var isLength = require('../internal/isLength'),
        isNative = require('../lang/isNative'),
        isObject = require('../lang/isObject'),
        shimKeys = require('../internal/shimKeys');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
        if (object) {
            var Ctor = object.constructor,
                length = object.length;
        }
        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
            (typeof object != 'function' && (length && isLength(length)))) {
            return shimKeys(object);
        }
        return isObject(object) ? nativeKeys(object) : [];
    };

    module.exports = keys;

},{"../internal/isLength":48,"../internal/shimKeys":56,"../lang/isNative":62,"../lang/isObject":63}],68:[function(require,module,exports){
    var isArguments = require('../lang/isArguments'),
        isArray = require('../lang/isArray'),
        isIndex = require('../internal/isIndex'),
        isLength = require('../internal/isLength'),
        isObject = require('../lang/isObject'),
        support = require('../support');

    /** Used for native method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
        if (object == null) {
            return [];
        }
        if (!isObject(object)) {
            object = Object(object);
        }
        var length = object.length;
        length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

        var Ctor = object.constructor,
            index = -1,
            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
            result = Array(length),
            skipIndexes = length > 0;

        while (++index < length) {
            result[index] = (index + '');
        }
        for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
            }
        }
        return result;
    }

    module.exports = keysIn;

},{"../internal/isIndex":47,"../internal/isLength":48,"../lang/isArguments":58,"../lang/isArray":59,"../lang/isObject":63,"../support":70}],69:[function(require,module,exports){
    var baseToString = require('../internal/baseToString');

    /**
     * Used to match `RegExp` special characters.
     * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
     * for more details.
     */
    var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
        reHasRegExpChars = RegExp(reRegExpChars.source);

    /**
     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
        string = baseToString(string);
        return (string && reHasRegExpChars.test(string))
            ? string.replace(reRegExpChars, '\\$&')
            : string;
    }

    module.exports = escapeRegExp;

},{"../internal/baseToString":33}],70:[function(require,module,exports){
    (function (global){
        var isNative = require('./lang/isNative');

        /** Used to detect functions containing a `this` reference. */
        var reThis = /\bthis\b/;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to detect DOM support. */
        var document = (document = global.window) && document.document;

        /** Native method references. */
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;

        /**
         * An object environment feature flags.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        var support = {};

        (function(x) {

            /**
             * Detect if functions can be decompiled by `Function#toString`
             * (all but Firefox OS certified apps, older Opera mobile browsers, and
             * the PlayStation 3; forced `false` for Windows 8 apps).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

            /**
             * Detect if `Function#name` is supported (all but IE).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcNames = typeof Function.name == 'string';

            /**
             * Detect if the DOM is supported.
             *
             * @memberOf _.support
             * @type boolean
             */
            try {
                support.dom = document.createDocumentFragment().nodeType === 11;
            } catch(e) {
                support.dom = false;
            }

            /**
             * Detect if `arguments` object indexes are non-enumerable.
             *
             * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
             * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
             * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
             * checks for indexes that exceed their function's formal parameters with
             * associated values of `0`.
             *
             * @memberOf _.support
             * @type boolean
             */
            try {
                support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
            } catch(e) {
                support.nonEnumArgs = true;
            }
        }(0, 0));

        module.exports = support;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lang/isNative":62}],71:[function(require,module,exports){
    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
        return value;
    }

    module.exports = identity;

},{}],72:[function(require,module,exports){
    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
        // No operation performed.
    }

    module.exports = noop;

},{}],73:[function(require,module,exports){
    "use strict";
    var keys = require( "lodash/object/keys" );
    var forEach = require( "lodash/collection/forEach" );
    var reduce = require( "lodash/collection/reduce" );
    var isEmpty = require( "lodash/lang/isEmpty" );
    var isUndefined = require( "lodash/lang/isUndefined" );
    var isString = require( "lodash/lang/isString" );

    /**
     * @typedef FacetList
     * @type {Array.<string>}
     *
     * @typedef OperatorList
     * @type {Object.<string, number>}
     */

    /**
     * SearchParameters is the data structure that contains all the informations
     * usable for making a search to Algolia API. It doesn't do the search itself,
     * nor does it contains logic about the parameters.
     * It is an immutable object, therefore it has been created in a way that each
     * "mutation" does not mutate the object itself but returns a copy with the
     * modification.
     * This object should probably not be instantiated outside of the helper. It will
     * be provided when needed. This object is documented for reference as you'll
     * get it from events generated by the {Helper}.
     * @constructor
     * @classdesc contains all the parameters of a search
     */
    var SearchParameters = function( newParameters ) {
        var params = newParameters || {};
        //Query
        /**
         * Query used for the search.
         * @member {string}
         */
        this.query = params.query || "";
        //Facets
        /**
         * All the facets that will be requested to the server
         * @member {Object.<string, string>}
         */
        this.facets = params.facets || [];
        /**
         * All the declared disjunctive facets
         * @member {Object.<string, string>}
         */
        this.disjunctiveFacets = params.disjunctiveFacets || [];
        //Refinements
        /** @member {Object.<string, FacetList>}*/
        this.facetsRefinements = params.facetsRefinements || {};
        /** @member {Object.<string, FacetList>}*/
        this.facetsExcludes = params.facetsExcludes || {};
        /** @member {Object.<string, FacetList>}*/
        this.disjunctiveFacetsRefinements = params.disjunctiveFacetsRefinements || {};
        /**
         * @member {Object.<string, OperatorList>}
         */
        this.numericRefinements = params.numericRefinements || {};
        //Misc. parameters
        /** @member {number} */
        this.hitsPerPage = params.hitsPerPage || 20;
        /**
         * @member {number}
         **/
        this.maxValuesPerFacet = params.maxValuesPerFacet || 10;
        /** @member {number} */
        this.page = params.page || 0;

        /**
         * Possible values : prefixAll, prefixLast, prefixNone
         * @member {string}
         */
        this.queryType = params.queryType;
        /**
         * Possible values : true, false, min, strict
         * @member {string}
         */
        this.typoTolerance = params.typoTolerance;

        this.minWordSizefor1Typo = params.minWordSizefor1Typo;
        this.minWordSizefor2Typos = params.minWordSizefor2Typos;
        this.allowTyposOnNumericTokens = params.allowTyposOnNumericTokens;
        this.ignorePlurals = params.ignorePlurals;
        this.restrictSearchableAttributes = params.restrictSearchableAttributes;
        this.advancedSyntax = params.advancedSyntax;
        this.analytics = params.analytics;
        this.analyticsTags = params.analyticsTags;
        this.synonyms = params.synonyms;
        this.replaceSynonymsInHighlight = params.replaceSynonymsInHighlight;
        this.optionalWords = params.optionalWords;
        this.removeWordsIfNoResults = params.removeWordsIfNoResults;
        this.attributesToRetrieve = params.attributesToRetrieve;
        this.attributesToHighlight = params.attributesToHighlight;
        this.attributesToSnippet = params.attributesToSnippet;
        this.getRankingInfo = params.getRankingInfo;
        this.tagFilters = params.tagFilters;
        this.distinct = params.distinct;
        this.aroundLatLng = params.aroundLatLng;
        this.aroundLatLngViaIP = params.aroundLatLngViaIP;
        this.aroundRadius = params.aroundRadius;
        this.aroundPrecision = params.aroundPrecision;
        this.insideBoundingBox = params.insideBoundingBox;
    };

    SearchParameters.prototype = {
        constructor : SearchParameters,

        /**
         * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)
         * @method
         * @param {string} [name] - If given, name of the facet / attribute on which  we want to remove all refinements
         * @return {AlgoliaSearchHelper}
         */
        clearRefinements : function clearRefinements( name ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                m._clearNumericRefinements( name );
                m._clearFacetRefinements( name );
                m._clearExcludeRefinements( name );
                m._clearDisjunctiveFacetRefinements( name );
            } );
        },
        /**
         * Query setter
         * @method
         * @param {string} newQuery value for the new query
         * @return {SearchParameters}
         */
        setQuery : function setQuery( newQuery ) {
            return this.mutateMe( function( m ) {
                m.query = newQuery;
                m.page = 0;
            } );
        },
        /**
         * Page setter
         * @method
         * @param {number} newPage new page number
         * @return {SearchParameters}
         */
        setPage : function setPage( newPage ) {
            return this.mutateMe( function( mutable ) {
                mutable.page = newPage;
            } );
        },
        /**
         * Facets setter
         * The facets are the simple facets, used for conjunctive (and) facetting.
         * @method
         * @param {string[]} facets all the attributes of the algolia records used for conjunctive facetting
         * @return {SearchParameters}
         */
        setFacets : function setFacets( facets ) {
            return this.mutateMe( function( m ) {
                m.facets = facets;
            } );
        },
        /**
         * Disjunctive facets setter
         * Change the list of disjunctive (or) facets the helper chan handle.
         * @method
         * @param {string[]} facets all the attributes of the algolia records used for disjunctive facetting
         * @return {SearchParameters}
         */
        setDisjunctiveFacets : function setDisjunctiveFacets( facets ) {
            return this.mutateMe( function( m ) {
                m.disjunctiveFacets = facets;
            } );
        },
        /**
         * HitsPerPage setter
         * Hits per page represents the number of hits retrieved for this query
         * @method
         * @param {number} n number of hits retrieved per page of results
         * @return {SearchParameters}
         */
        setHitsPerPage : function setHitsPerPage( n ) {
            return this.mutateMe( function( m ) {
                m.HitsPerPage = n;
                m.page = 0;
            } );
        },
        /**
         * Add or update a numeric filter for a given attribute
         * Current limitation of the numeric filters : you can't have more than one value
         * filtered for each (attribute, oprator). It means that you can't have a filter
         * for ( "attribute", "=", 3 ) and ( "attribute", "=", 8 )
         * @method
         * @param {string} attribute attribute to set the filter on
         * @param {string} operator operator of the filter ( possible values : =, >, >=, <, <=, != )
         * @param {number} value value of the filter
         */
        addNumericRefinement : function( attribute, operator, value ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                if( !m.numericRefinements[ attribute ] ) {
                    m.numericRefinements[ attribute ] = {};
                }
                m.numericRefinements[ attribute ][ operator ] = value;
            } );
        },
        /**
         * Remove a numeric filter
         * @method
         * @param {string} attribute attribute to set the filter on
         * @param {string} operator operator of the filter ( possible values : =, >, >=, <, <=, != )
         */
        removeNumericRefinement : function( attribute, operator ) {
            return this.mutateMe( function( m ) {
                if( m.numericRefinements[ attribute ] ) {
                    m.page = 0;
                    var value = m.numericRefinements[ attribute ][ operator ];
                    if( !isUndefined( value ) ) {
                        delete m.numericRefinements[ attribute ][ operator ];
                        if( isEmpty( m.numericRefinements[ attribute ] ) ) {
                            delete m.numericRefinements[ attribute ];
                        }
                    }
                }
            } );
        },
        /**
         * Return the current refinement for the ( attribute, operator )
         * @param {string} attribute of the record
         * @param {string} operator applied
         * @return {number} value of the refinement
         */
        getNumericRefinement : function( attribute, operator ){
            return this.numericRefinements[ attribute ] && this.numericRefinements[ attribute ][ operator ];
        },
        /**
         * Clear numeric filters.
         * @method
         * @private
         * @param {string} [attribute] -
         * - If not given, means to clear all the filters.
         * - If `string`, means to clear all refinements for the `attribute` named filter.
         */
        _clearNumericRefinements : function _clearNumericRefinements( attribute ) {
            if ( isUndefined( attribute ) ) {
                this.numericRefinements = {};
            }
            else if ( isString( attribute ) ) {
                if ( !isUndefined( this.numericRefinements[ attribute ] ) ) {
                    delete this.numericRefinements[ attribute ];
                }
            }
        },
        /**
         * Add a refinement on a "normal" facet
         * @method
         * @param {string} facet attribute to apply the facetting on
         * @param {string} value value of the attribute
         * @return {SearchParameters}
         */
        addFacetRefinement : function addFacetRefinement( facet, value ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                m.facetsRefinements[ facet ] = value;
            } );
        },
        /**
         * Exclude a value from a "normal" facet
         * @method
         * @param {string} facet attribute to apply the exclusion on
         * @param {string} value value of the attribute
         * @return {SearchParameters}
         */
        addExcludeRefinement : function addExcludeRefinement( facet, value ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                if( !m.facetsExcludes[ facet ] ) {
                    m.facetsExcludes[ facet ] = [];
                }
                m.facetsExcludes[ facet ].push( value );
            } );
        },
        /**
         * Adds a refinement on a disjunctive facet.
         * @method
         * @param {string} facet attribute to apply the facetting on
         * @param {string} value value of the attribute
         * @return {SearchParameters}
         */
        addDisjunctiveFacetRefinement : function addDisjunctiveFacetRefinement( facet, value ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                if( !m.disjunctiveFacetsRefinements[ facet ] ) {
                    m.disjunctiveFacetsRefinements[ facet ] = [];
                }
                m.disjunctiveFacetsRefinements[ facet ].push( value );
            } );
        },
        /**
         * Remove a refinement set on facet.
         * @method
         * @param {string} facet
         * @return {SearchParameters}
         */
        removeFacetRefinement : function removeFacetRefinement( facet ) {
            return this.mutateMe( function( m ) {
                m.page = 0;
                m._clearFacetRefinements( facet );
            } );
        },
        /**
         * Remove a negative refinement on a facet
         * @method
         * @param {string} facet
         * @param {string} value
         * @return {SearchParameters}
         */
        removeExcludeRefinement : function removeExcludeRefinement( facet, value ) {
            return this.mutateMe( function( m ) {
                if( m.facetsExcludes[ facet ] ) {
                    m.page = 0;
                    var idx = m.facetsExcludes[ facet ].indexOf( value );
                    if( idx > -1 ) {
                        m.facetsExcludes[ facet ].splice( idx, 1 );
                        if( m.facetsExcludes[ facet ].length === 0 ) {
                            delete m.facetsExcludes[ facet ];
                        }
                    }
                }
            } );
        },
        /**
         * Remove a refinement on a disjunctive facet
         * @method
         * @param {string} facet
         * @param {string} value
         * @return {SearchParameters}
         */
        removeDisjunctiveFacetRefinement : function removeDisjunctiveFacetRefinement( facet, value ) {
            return this.mutateMe( function( m ) {
                if( m.disjunctiveFacetsRefinements[ facet ] ) {
                    m.page = 0;
                    var idx = m.disjunctiveFacetsRefinements[ facet ].indexOf( value );
                    if( idx > -1 ) {
                        m.disjunctiveFacetsRefinements[ facet ].splice( idx, 1 );
                        if( m.disjunctiveFacetsRefinements[facet].length === 0 ) {
                            delete m.disjunctiveFacetsRefinements[ facet ];
                        }
                    }
                }
            } );
        },
        /**
         * Clear the facet refinements
         * @method
         * @private
         * @param {string} [facet] -
         * - If not given, means to clear the refinement of all facets.
         * - If `string`, means to clear the refinement for the `facet` named facet.
         */
        _clearFacetRefinements : function _clearFacetRefinements( facet ) {
            if ( isUndefined( facet ) ) {
                this.facetsRefinements = {};
            }
            else if ( isString( facet ) ) {
                if ( !isUndefined( this.facetsRefinements[ facet ] ) ) {
                    delete this.facetsRefinements[ facet ];
                }
            }
        },
        /**
         * Clear the exclude refinements
         * @method
         * @private
         * @param {string} [facet] -
         * - If not given, means to clear all the excludes of all facets.
         * - If `string`, means to clear all the excludes for the `facet` named facet.
         */
        _clearExcludeRefinements : function _clearExcludeRefinements( facet ) {
            if ( isUndefined( facet ) ) {
                this.facetsExcludes = {};
            }
            else if ( isString( facet ) ) {
                if ( !isUndefined( this.facetsExcludes[ facet ] ) ) {
                    delete this.facetsExcludes[ facet ];
                }
            }
        },
        /**
         * Clear the disjunctive refinements
         * @method
         * @private
         * @param {string} [facet] -
         * - If not given, means to clear all the refinements of all disjunctive facets.
         * - If `string`, means to clear all the refinements for the `facet` named facet.
         */
        _clearDisjunctiveFacetRefinements : function _clearDisjunctiveFacetRefinements( facet ) {
            if ( isUndefined( facet ) ) {
                this.disjunctiveFacetsRefinements = {};
            }
            else if ( isString( facet ) ) {
                if ( !isUndefined( this.disjunctiveFacetsRefinements[ facet ] ) ) {
                    delete this.disjunctiveFacetsRefinements[ facet ];
                }
            }
        },
        /**
         * Switch the refinement applied over a facet/value
         * @method
         * @param {string} facet
         * @param {value} value
         * @return {SearchParameters}
         */
        toggleFacetRefinement : function toggleFacetRefinement( facet, value ) {
            if( this.isFacetRefined( facet, value ) ) {
                return this.removeFacetRefinement( facet );
            }
            else {
                return this.addFacetRefinement( facet, value );
            }
        },
        /**
         * Switch the refinement applied over a facet/value
         * @method
         * @param {string} facet
         * @param {value} value
         * @return {SearchParameters}
         */
        toggleExcludeFacetRefinement : function toggleExcludeFacetRefinement( facet, value ) {
            if( this.isExcludeRefined( facet, value ) ) {
                return this.removeExcludeRefinement( facet, value );
            }
            else {
                return this.addExcludeRefinement( facet, value );
            }
        },
        /**
         * Switch the refinement applied over a facet/value
         * @method
         * @param {string} facet
         * @param {value} value
         * @return {SearchParameters}
         */
        toggleDisjunctiveFacetRefinement : function toggleDisjunctiveFacetRefinement( facet, value ) {
            if( this.isDisjunctiveFacetRefined( facet, value ) ) {
                return this.removeDisjunctiveFacetRefinement( facet, value );
            }
            else {
                return this.addDisjunctiveFacetRefinement( facet, value );
            }
        },
        /**
         * Returns true if the couple (facet, value) is refined
         * @method
         * @param {string} facet
         * @param {string} value
         * @return {boolean}
         */
        isFacetRefined : function isFacetRefined( facet, value ) {
            return this.facetsRefinements[ facet ] === value;
        },
        /**
         * Returns true if the couple (facet, value) is excluded
         * @method
         * @param {string} facet
         * @param {string} value
         * @return {boolean}
         */
        isExcludeRefined : function isExcludeRefined( facet, value ) {
            return this.facetsExcludes[ facet ] &&
                this.facetsExcludes[ facet ].indexOf( value ) !== -1;
        },
        /**
         * Returns true if the couple (facet, value) is refined
         * @method
         * @param {string} facet
         * @param {string} value
         * @return {boolean}
         */
        isDisjunctiveFacetRefined : function isDisjunctiveFacetRefined( facet, value ) {
            return this.disjunctiveFacetsRefinements[ facet ] &&
                this.disjunctiveFacetsRefinements[ facet ].indexOf( value ) !== -1;
        },
        /**
         * Returns the list of all disjunctive facets refined
         * @method
         * @param {string} facet
         * @param {value} value
         * @return {string[]}
         */
        getRefinedDisjunctiveFacets : function getRefinedDisjunctiveFacets() {
            return keys( this.disjunctiveFacetsRefinements).concat( keys ( this.numericRefinements ) );
        },
        /**
         * Returned the list of all disjunctive facets not refined
         * @method
         * @return {string[]}
         */
        getUnrefinedDisjunctiveFacets : function() {
            var unrefinedFacets = [];
            var refinedFacets = this.getRefinedDisjunctiveFacets();
            forEach( this.disjunctiveFacets, function( f ) {
                if( refinedFacets.indexOf( f ) === -1 ) {
                    unrefinedFacets.push( f );
                }
            } );
            return unrefinedFacets;
        },
        managedParameters : [
            "facets", "disjunctiveFacets", "facetsRefinements",
            "facetsExcludes", "disjunctiveFacetsRefinements",
            "numericRefinements"
        ],
        getQueryParams : function getQueryParams() {
            var managedParameters = this.managedParameters;
            return reduce( this, function( memo, value, parameter, parameters ) {
                if( managedParameters.indexOf( parameter ) === -1 &&
                    parameters[ parameter ] !== undefined ) {
                    memo[ parameter ] = value;
                }
                return memo;
            }, {} );
        },
        /**
         * Helper function to make it easier to build new instances from a mutating
         * function
         * @private
         */
        mutateMe : function mutateMe( fn ) {
            var newState = new ( this.constructor )( this );
            fn( newState );
            return Object.freeze( newState );
        }
    };

    module.exports = SearchParameters;

},{"lodash/collection/forEach":10,"lodash/collection/reduce":11,"lodash/lang/isEmpty":60,"lodash/lang/isString":64,"lodash/lang/isUndefined":66,"lodash/object/keys":67}],74:[function(require,module,exports){
    "use strict";
    var forEach = require( "lodash/collection/forEach" );
    var compact = require( "lodash/array/compact" );
    var find = require( "lodash/collection/find" );

    function getIndices( obj ) {
        var indices = {};
        forEach( obj, function( val, idx ) { indices[ val ] = idx; } );
        return indices;
    }

    function assignFacetStats( dest, facetStats, key ) {
        if ( facetStats && facetStats[key] ) {
            dest.stats = facetStats[key];
        }
    }

    function assignFacetTimeout( dest, timeoutCounts, getRankingInfo ) {
        if ( getRankingInfo ) {
            dest.timeout = !!( timeoutCounts );
        }
    }

    /**
     * Constructor for SearchResults
     * @class
     * @classdesc SearchResults is an object that contains all the data from a
     * helper query.
     * @param {SearchParameters} state state that led to the response
     * @param {object} algoliaResponse the response from algolia client
     **/
    var SearchResults = function( state, algoliaResponse ) {
        var mainSubResponse = algoliaResponse.results[ 0 ];

        /**
         * query used to generate the results
         * @member {string}
         */
        this.query = mainSubResponse.query;
        /**
         * all the hits generated for the query
         * @member {array}
         */
        this.hits = mainSubResponse.hits;
        /**
         * index where the results come from
         * @member {string}
         */
        this.index = mainSubResponse.index;
        /**
         * number of hits per page requested
         * @member {number}
         */
        this.hitsPerPage = mainSubResponse.hitsPerPage;
        /**
         * total number of hits of this query on the index
         * @member {number}
         */
        this.nbHits = mainSubResponse.nbHits;
        /**
         * total number of pages with respect to the number of hits per page and the total number of hits
         * @member {number}
         */
        this.nbPages = mainSubResponse.nbPages;
        /**
         * current page
         * @member {number}
         */
        this.page = mainSubResponse.page;
        /**
         * processing time of the main query
         * @member {number}
         */
        this.processingTimeMS = mainSubResponse.processingTimeMS;
        /**
         * disjunctive facets results
         * @member {array}
         */
        this.disjunctiveFacets = [];
        /**
         * other facets results
         * @member {array}
         */
        this.facets = [];

        var disjunctiveFacets = state.getRefinedDisjunctiveFacets();

        var facetsIndices = getIndices( state.facets );
        var disjunctiveFacetsIndices = getIndices( state.disjunctiveFacets );

        //Since we send request only for disjunctive facets that have been refined,
        //we get the facets informations from the first, general, response.
        forEach( mainSubResponse.facets, function( facetValueObject, facetKey ) {
            var isFacetDisjunctive = state.disjunctiveFacets.indexOf( facetKey ) !== -1;
            var position = isFacetDisjunctive ? disjunctiveFacetsIndices[ facetKey ] :
                facetsIndices[ facetKey ];
            if( isFacetDisjunctive ) {
                this.disjunctiveFacets[ position ] = {
                    name : facetKey,
                    data : facetValueObject
                };
                assignFacetStats( this.disjunctiveFacets[ position ], mainSubResponse.facets_stats, facetKey );
                assignFacetTimeout( this.disjunctiveFacets[ position ],
                    state.getRankingInfo,
                    mainSubResponse.timeoutCounts,
                    facetKey );
            }
            else {
                this.facets[ position ] = {
                    name : facetKey,
                    data : facetValueObject
                };
                assignFacetStats( this.facets[ position ], mainSubResponse.facets_stats, facetKey );
                assignFacetTimeout( this.facets[ position ], state.getRankingInfo, mainSubResponse.timeoutCounts, facetKey );
            }
        }, this );

        // aggregate the refined disjunctive facets
        forEach( disjunctiveFacets, function( disjunctiveFacet, idx ) {
            var result = algoliaResponse.results[ idx + 1 ];

            // There should be only item in facets.
            forEach( result.facets, function( facetResults, dfacet ) {
                var position = disjunctiveFacetsIndices[ dfacet ];

                this.disjunctiveFacets[ position ] = {
                    name : dfacet,
                    data : facetResults
                };
                assignFacetStats( this.disjunctiveFacets[ position ], result.facets_stats, dfacet );
                assignFacetTimeout( this.disjunctiveFacets[ position ], state.getRankingInfo, result.timeoutCounts, dfacet );

                if ( state.disjunctiveFacetsRefinements[dfacet] ) {
                    forEach( state.disjunctiveFacetsRefinements[ dfacet ], function( refinementValue ) {
                        // add the disjunctive refinements if it is no more retrieved
                        if ( !this.disjunctiveFacets[position].data[refinementValue] &&
                            state.disjunctiveFacetsRefinements[dfacet].indexOf( refinementValue ) > -1 ) {
                            this.disjunctiveFacets[position].data[refinementValue] = 0;
                        }
                    }, this );
                }
            }, this );
        }, this );

        // add the excludes
        forEach( state.facetsExcludes, function( excludes, facetName ) {
            var position = facetsIndices[ facetName ];
            this.facets[ position ] = {
                name : facetName,
                data : mainSubResponse.facets[ facetName ]
            };
            forEach( excludes, function( facetValue ) {
                this.facets[ position ] = this.facets[ position ] || { name : facetName };
                this.facets[ position ].data = this.facets[ position ].data || {};
                this.facets[ position ].data[ facetValue ] = 0;
            }, this );
        }, this );

        this.facets = compact( this.facets );
        this.disjunctiveFacets = compact( this.disjunctiveFacets );

        this._state = state;
    };

    SearchResults.prototype.getFacetByName = function( name ) {
        var isName = function( facet ) { return facet.name === name; };
        var indexInFacets = find( this.facets, isName );
        return indexInFacets || find( this.disjunctiveFacets, isName );
    };

    module.exports = SearchResults;

},{"lodash/array/compact":7,"lodash/collection/find":9,"lodash/collection/forEach":10}],75:[function(require,module,exports){
    "use strict";
    var SearchParameters = require( "./SearchParameters" );
    var SearchResults = require( "./SearchResults" );
    var extend = require( "./functions/extend" );
    var util = require( "util" );
    var events = require( "events" );
    var forEach = require( "lodash/collection/forEach" );
    var bind = require( "lodash/function/bind" );

    /**
     * Initialize a new AlgoliaSearchHelper
     * @class
     * @classdesc The AlgoliaSearchHelper is a class that ease the management of the
     * search. It provides an event based interface for search callbacks :
     *  - change : when the internal search state is changed. This event contains a {SearchParameters} object
     *  - result : when the response is retrieved from Algolia and is processed. This event contains a {SearchResults} object
     *  - error  : when the response is an error. This event contains the error returned by the server.
     * @param  {AlgoliaSearch} client an AlgoliaSearch client
     * @param  {string} index the index name to query
     * @param  {SearchParameters | object} options an object defining the initial config of the search. It doesn't have to be a {SearchParamaters}, just an object containing the properties you need from it.
     */
    function AlgoliaSearchHelper( client, index, options ) {
        this.client = client;
        this.index = index;
        this.state = new SearchParameters( options );
    }

    util.inherits( AlgoliaSearchHelper, events.EventEmitter );

    /**
     * Start the search with the parameters set in the state.
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.search = function() {
        this._search();
        return this;
    };

    /**
     * Sets the query. Also sets the current page to 0.
     * @param  {string} q the user query
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.setQuery = function( q ) {
        this.state = this.state.setQuery( q );

        this.emit( "change", this.state );
        return this;
    };

    /**
     * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)
     * @param {string} [name] - If given, name of the facet / attribute on which  we want to remove all refinements
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.clearRefinements = function( name ) {
        this.state = this.state.clearRefinements( name );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet refinement exists
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.addDisjunctiveRefine = function( facet, value ) {
        this.state = this.state.addDisjunctiveFacetRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet refinement does not exist
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.removeDisjunctiveRefine = function( facet, value ) {
        this.state = this.state.removeDisjunctiveFacetRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Add a numeric refinement on the given attribute
     * @param  {string} attribute
     * @param  {string} operator
     * @param  {number} value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.addNumericRefinement = function( attribute, operator, value ) {
        this.state = this.state.addNumericRefinement( attribute, operator, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Remove a numeric filter.
     * @param  {string} attribute
     * @param  {string} operator
     * @param  {number} value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.removeNumericRefinement = function( attribute, operator, value ) {
        this.state = this.state.removeNumericRefinement( attribute, operator, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet refinement exists
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.addRefine = function( facet, value ) {
        this.state = this.state.addFacetRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet refinement does not exist
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.removeRefine = function( facet, value ) {
        this.state = this.state.removeFacetRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet exclude exists
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.addExclude = function( facet, value ) {
        this.state = this.state.addExcludeRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Ensure a facet exclude does not exist
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.removeExclude = function( facet, value ) {
        this.state = this.state.removeExcludeRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Toggle refinement state of an exclude
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.toggleExclude = function( facet, value ) {
        this.state = this.state.toggleExcludeFacetRefinement( facet, value );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Toggle refinement state of a facet
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.toggleRefine = function( facet, value ) {
        if( this.state.facets.indexOf( facet ) > -1 ) {
            this.state = this.state.toggleFacetRefinement( facet, value );
        }
        else if( this.state.disjunctiveFacets.indexOf( facet ) > -1 ) {
            this.state = this.state.toggleDisjunctiveFacetRefinement( facet, value );
        }
        else {
            /* eslint-disable */
            console.log( "warning : you're trying to refine the undeclared facet '" + facet +
            "'; add it to the helper options 'facets' or 'disjunctiveFacets'" );
            /* eslint-enable */
            return this;
        }
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Go to next page
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.nextPage = function() {
        return this.setCurrentPage( this.state.page + 1 );
    };

    /**
     * Go to previous page
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.previousPage = function() {
        return this.setCurrentPage( this.state.page - 1 );
    };

    /**
     * Change the current page
     * @param  {integer} page The page number
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.setCurrentPage = function( page ) {
        if( page < 0 ) throw new Error( "Page requested below 0." );

        this.state = this.state.setPage( page );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Configure the underlying index name
     * @param {string} name the index name
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.setIndex = function( name ) {
        this.index = name;
        return this;
    };

    /**
     * Set the whole state ( warning : will erase previous state )
     * @param {SearchParameters} newState the whole new state
     * @return {AlgoliaSearchHelper}
     */
    AlgoliaSearchHelper.prototype.setState = function( newState ) {
        this.state = new SearchParameters( newState );
        this.emit( "change", this.state );
        return this;
    };

    /**
     * Check the refinement state of a facet
     * @param  {string}  facet the facet
     * @param  {string}  value the associated value
     * @return {boolean} true if refined
     */
    AlgoliaSearchHelper.prototype.isRefined = function( facet, value ) {
        if( this.state.facets.indexOf( facet ) > -1 ) {
            return this.state.isFacetRefined( facet, value );
        }
        else if( this.state.disjunctiveFacets.indexOf( facet ) > -1 ) {
            return this.state.isDisjunctiveFacetRefined( facet, value );
        }
        return false;
    };

    /**
     * Check the exclude state of a facet
     * @param  {string}  facet the facet
     * @param  {string}  value the associated value
     * @return {boolean} true if refined
     */
    AlgoliaSearchHelper.prototype.isExcluded = function( facet, value ) {
        return this.state.isExcludeRefined( facet, value );
    };

    /**
     * Check the refinement state of the disjunctive facet
     * @param  {string}  facet the facet
     * @param  {string}  value the associated value
     * @return {boolean} true if refined
     */
    AlgoliaSearchHelper.prototype.isDisjunctiveRefined = function( facet, value ) {
        return this.state.isDisjunctiveFacetRefined( facet, value );
    };

    /**
     * Get the underlying configured index name
     */
    AlgoliaSearchHelper.prototype.getIndex = function() {
        return this.index;
    };

    /**
     * Get the currently selected page
     * @return Number the current page
     */
    AlgoliaSearchHelper.prototype.getCurrentPage = function() {
        return this.state.page;
    };

///////////// PRIVATE

    /**
     * Perform the underlying queries
     * @private
     */
    AlgoliaSearchHelper.prototype._search = function() {
        var state = this.state;

        this.client.startQueriesBatch();

        //One query for the hits
        this.client.addQueryInBatch( this.index, state.query, this._getHitsSearchParams() );

        //One for each disjunctive facets
        forEach( state.getRefinedDisjunctiveFacets(), function( refinedFacet ) {
            this.client.addQueryInBatch( this.index, state.query, this._getDisjunctiveFacetSearchParams( refinedFacet ) );
        }, this );

        this.client.sendQueriesBatch( bind( this._handleResponse, this, state ) );
    };

    /**
     * Transform the response as sent by the server and transform it into a user
     * usable objet that merge the results of all the batch requests.
     * @private
     * @param {SearchParameters} state state used for to generate the request
     * @param {Error} err error if any, null otherwise
     * @param {object} content content of the response
     */
    AlgoliaSearchHelper.prototype._handleResponse = function( state, err, content ) {
        if ( err ) {
            this.emit( "error", err );
            return;
        }

        var formattedResponse = new SearchResults( state, content );

        this.emit( "result", formattedResponse );
    };

    /**
     * Build search parameters used to fetch hits
     * @private
     * @return {object.<string, any>}
     */
    AlgoliaSearchHelper.prototype._getHitsSearchParams = function() {
        var facets = this.state.facets.concat( this.state.getUnrefinedDisjunctiveFacets() );
        var facetFilters = this._getFacetFilters();
        var numericFilters = this._getNumericFilters();
        var additionalParams = {
            facets : facets,
            distinct : false
        };

        if( facetFilters.length > 0 ) {
            additionalParams.facetFilters = facetFilters;
            additionalParams.distinct = this.state.distinct || false;
        }

        if( numericFilters.length > 0 ) {
            additionalParams.numericFilters = numericFilters;
        }

        return extend( this.state.getQueryParams(), additionalParams );
    };

    /**
     * Build search parameters used to fetch a disjunctive facet
     * @private
     * @param  {string} facet the associated facet name
     * @return {object}
     */
    AlgoliaSearchHelper.prototype._getDisjunctiveFacetSearchParams = function( facet ) {
        var facetFilters = this._getFacetFilters( facet );
        var numericFilters = this._getNumericFilters( facet );

        var additionalParams = {
            hitsPerPage : 1,
            page : 0,
            attributesToRetrieve : [],
            attributesToHighlight : [],
            attributesToSnippet : [],
            facets : facet,
            distinct : false
        };

        if( numericFilters.length > 0 ) {
            additionalParams.numericFilters = numericFilters;
        }

        if( facetFilters.length > 0 ) {
            additionalParams.facetFilters = facetFilters;
            additionalParams.distinct = this.state.distinct || false;
        }

        return extend( this.state.getQueryParams(), additionalParams );
    };

    /**
     * Return the numeric filters in an algolia request fashion
     * @private
     * @return {array.<string>} the numeric filters in the algolia format
     */
    AlgoliaSearchHelper.prototype._getNumericFilters = function( facet ) {
        var numericFilters = [];
        forEach( this.state.numericRefinements, function( operators, attribute ) {
            forEach( operators, function( value, operator ) {
                if ( attribute != facet )
                    numericFilters.push( attribute + operator + value );
            } );
        } );
        return numericFilters;
    };

    /**
     * Test if there are some disjunctive refinements on the facet
     * @private
     */
    AlgoliaSearchHelper.prototype._hasDisjunctiveRefinements = function( facet ) {
        return this.state.disjunctiveRefinements[ facet ] &&
            this.state.disjunctiveRefinements[ facet ].length > 0;
    };

    /**
     * Build facetFilters parameter based on current refinements. The array returned
     * contains strings representing the facet filters in the algolia format.
     * @private
     * @param  {string} facet if set, the current disjunctive facet
     * @return {array.<string>}
     */
    AlgoliaSearchHelper.prototype._getFacetFilters = function( facet ) {
        var facetFilters = [];

        forEach( this.state.facetsRefinements, function( facetValue, facetName ) {
            facetFilters.push( facetName + ":" + facetValue );
        } );

        forEach( this.state.facetsExcludes, function( facetValues, facetName ) {
            forEach( facetValues, function( facetValue ) {
                facetFilters.push( facetName + ":-" + facetValue );
            } );
        } );

        forEach( this.state.disjunctiveFacetsRefinements, function( facetValues, facetName ) {
            if( facetName === facet || !facetValues || facetValues.length === 0 ) return;
            var orFilters = [];
            forEach( facetValues, function( facetValue ) {
                orFilters.push( facetName + ":" + facetValue );
            } );
            facetFilters.push( orFilters );
        } );

        return facetFilters;
    };

    module.exports = AlgoliaSearchHelper;

},{"./SearchParameters":73,"./SearchResults":74,"./functions/extend":76,"events":2,"lodash/collection/forEach":10,"lodash/function/bind":13,"util":6}],76:[function(require,module,exports){
    "use strict";
    module.exports = function extend( out ) {
        out = out || {};
        for ( var i = 1; i < arguments.length; i++ ) {
            if ( !arguments[i] ) {
                continue;
            }
            for ( var key in arguments[i] ) {
                if ( arguments[i].hasOwnProperty( key ) ) {
                    out[key] = arguments[i][key];
                }
            }
        }
        return out;
    };

},{}]},{},[1])(1)
});